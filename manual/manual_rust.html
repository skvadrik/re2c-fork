
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>User manual (Rust) &#8212; re2c 4.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/theme-re2c.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="alternate" type="application/atom+xml" href="../feed/atom.xml" title="Atom 1.0" />
    
 
  </head><body>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="re2c-logo">
    re2c
</div>

<h3><a href="../index.html">Home</a></h3>
<div class="re2c-toc-global">
    <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="manual.html">User manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../build/build.html">Build &amp; install</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks/benchmarks.html">Benchmarks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../releases/release_notes.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../releases/changelog/changelog.html">Changelog</a></li>
</ul>

</div>
    <h3>User manual (Rust)</h3>
    <div class="re2c-toc-local">
        <ul>
<li><a class="reference internal" href="#">User manual (Rust)</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#basics">Basics</a><ul>
<li><a class="reference internal" href="#blocks">Blocks</a></li>
<li><a class="reference internal" href="#configurations">Configurations</a></li>
<li><a class="reference internal" href="#regular-expressions">Regular expressions</a></li>
<li><a class="reference internal" href="#actions">Actions</a></li>
<li><a class="reference internal" href="#directives">Directives</a></li>
<li><a class="reference internal" href="#program-interface">Program interface</a></li>
<li><a class="reference internal" href="#options">Options</a></li>
<li><a class="reference internal" href="#warnings">Warnings</a></li>
<li><a class="reference internal" href="#syntax-files">Syntax files</a></li>
</ul>
</li>
<li><a class="reference internal" href="#handling-the-end-of-input">Handling the end of input</a><ul>
<li><a class="reference internal" href="#sentinel">Sentinel</a></li>
<li><a class="reference internal" href="#sentinel-with-bounds-checks">Sentinel with bounds checks</a></li>
<li><a class="reference internal" href="#bounds-checks-with-padding">Bounds checks with padding</a></li>
<li><a class="reference internal" href="#custom-checks">Custom checks</a></li>
</ul>
</li>
<li><a class="reference internal" href="#buffer-refilling">Buffer refilling</a><ul>
<li><a class="reference internal" href="#yyfill-with-sentinel">YYFILL with sentinel</a></li>
<li><a class="reference internal" href="#yyfill-with-padding">YYFILL with padding</a></li>
</ul>
</li>
<li><a class="reference internal" href="#features">Features</a><ul>
<li><a class="reference internal" href="#multiple-blocks">Multiple blocks</a></li>
<li><a class="reference internal" href="#start-conditions">Start conditions</a></li>
<li><a class="reference internal" href="#storable-state">Storable state</a></li>
<li><a class="reference internal" href="#reusable-blocks">Reusable blocks</a></li>
<li><a class="reference internal" href="#submatch-extraction">Submatch extraction</a></li>
<li><a class="reference internal" href="#encoding-support">Encoding support</a></li>
<li><a class="reference internal" href="#include-files">Include files</a></li>
<li><a class="reference internal" href="#header-files">Header files</a></li>
<li><a class="reference internal" href="#skeleton-programs">Skeleton programs</a></li>
<li><a class="reference internal" href="#visualization-and-debug">Visualization and debug</a></li>
</ul>
</li>
<li><a class="reference internal" href="#more-examples">More examples</a></li>
</ul>
</li>
</ul>

    </div>

        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="user-manual-rust">
<h1>User manual (Rust)<a class="headerlink" href="#user-manual-rust" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p style="color:gray";><i></i></p><section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>re2rust works as a preprocessor. It reads the input file (which is usually a
program in Rust, but can be anything) and looks for blocks of code
enclosed in special-form start/end markers. The text outside of these blocks is
copied verbatim into the output file. The contents of the blocks are processed
by re2rust. It translates them to code in Rust and outputs the generated
code in place of the block.</p>
<p>Here is an example of a small program that checks if a given string contains a
decimal number:</p>
<p><a class="reference external" href="../../playground?example=rust/01_basic.re"><img alt="run_01_basic" class="feed" src="../_images/play.png" style="width: 2em;" /></a>   <a class="reference external" href="../../playground?example=rust/01_basic.re">Run in playground</a></p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2rust $INPUT -o $OUTPUT --no-unsafe --api simple</span>

<span class="k">fn</span> <span class="nf">lex</span><span class="p">(</span><span class="n">yyinput</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">yycursor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="sd">/*!re2c</span>
<span class="sd">        re2c:YYCTYPE = u8;</span>
<span class="sd">        re2c:yyfill:enable = 0;</span>

<span class="sd">        [1-9][0-9]* { return true; }</span>
<span class="sd">        *           { return false; }</span>
<span class="sd">    */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">b&quot;1234</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In the output re2rust replaced the middle block with the generated code:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Generated by re2rust */</span><span class="w"></span>
<span class="c1">// re2rust $INPUT -o $OUTPUT --no-unsafe --api simple</span>

<span class="k">fn</span> <span class="nf">lex</span><span class="p">(</span><span class="n">yyinput</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">yycursor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[allow(unused_assignments)]</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">yych</span><span class="w"> </span>: <span class="kt">u8</span> <span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">yystate</span><span class="w"> </span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="o">&#39;</span><span class="na">yyl</span>: <span class="nc">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">yystate</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="mi">0</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">yych</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">yyinput</span><span class="p">[</span><span class="n">yycursor</span><span class="p">];</span><span class="w"></span>
<span class="w">                </span><span class="n">yycursor</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="k">match</span><span class="w"> </span><span class="n">yych</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="mh">0x31</span><span class="w"> </span><span class="o">..=</span><span class="w"> </span><span class="mh">0x39</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="n">yystate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">                        </span><span class="k">continue</span><span class="w"> </span><span class="nl">&#39;yyl</span><span class="p">;</span><span class="w"></span>
<span class="w">                    </span><span class="p">}</span><span class="w"></span>
<span class="w">                    </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="n">yystate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">                        </span><span class="k">continue</span><span class="w"> </span><span class="nl">&#39;yyl</span><span class="p">;</span><span class="w"></span>
<span class="w">                    </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="mi">1</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">            </span><span class="mi">2</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">yych</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">yyinput</span><span class="p">[</span><span class="n">yycursor</span><span class="p">];</span><span class="w"></span>
<span class="w">                </span><span class="k">match</span><span class="w"> </span><span class="n">yych</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="mh">0x30</span><span class="w"> </span><span class="o">..=</span><span class="w"> </span><span class="mh">0x39</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="n">yycursor</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">                        </span><span class="n">yystate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">                        </span><span class="k">continue</span><span class="w"> </span><span class="nl">&#39;yyl</span><span class="p">;</span><span class="w"></span>
<span class="w">                    </span><span class="p">}</span><span class="w"></span>
<span class="w">                    </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="n">yystate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"></span>
<span class="w">                        </span><span class="k">continue</span><span class="w"> </span><span class="nl">&#39;yyl</span><span class="p">;</span><span class="w"></span>
<span class="w">                    </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="mi">3</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&quot;internal lexer error&quot;</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">b&quot;1234</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="basics">
<h2>Basics<a class="headerlink" href="#basics" title="Permalink to this headline">¶</a></h2>
<p>A re2rust program consists of a sequence of <em>blocks</em> intermixed with code in the
target language. A block may contain <em>definitions</em>, <em>configurations</em>, <em>rules</em>,
<em>actions</em> and <em>directives</em> in any order:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span> <span class="pre">=</span> <span class="pre">regular-expression</span> <span class="pre">;</span></code></dt><dd><p>A <em>definition</em> binds <code class="docutils literal notranslate"><span class="pre">name</span></code> to <code class="docutils literal notranslate"><span class="pre">regular-expression</span></code>. Names may contain
alphanumeric characters and underscore. The <a class="reference internal" href="#regular-expressions">regular expressions</a> section
gives an overview of re2rust syntax for regular expressions. Once defined,
the <code class="docutils literal notranslate"><span class="pre">name</span></code> can be used in other regular expressions and in rules.
Recursion in named definitions is not allowed, and each name should be
defined before it is used. A block inherits named definitions from the
global scope. Redefining a name that exists in the current scope is an error.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">configuration</span> <span class="pre">=</span> <span class="pre">value</span> <span class="pre">;</span></code></dt><dd><p>A <em>configuration</em> allows one to change re2rust behavior and customize the
generated code. For a full list of configurations supported by re2rust see
the <a class="reference internal" href="#configurations">configurations</a> section. Depending on a particular configuration, the
<code class="docutils literal notranslate"><span class="pre">value</span></code> can be a keyword, a nonnegative integer number or a one-line string
which should be enclosed in double or single quotes unless it consists of
alphanumeric characters. A block inherits configurations from the global
scope and may redefine them or add new ones. Configurations defined inside
of a block affect the whole block, even if they appear at the end of it.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">regular-expression</span> <span class="pre">code</span></code></dt><dd><p>A <em>rule</em> binds <code class="docutils literal notranslate"><span class="pre">regular-expression</span></code> to its semantic action (a block of
code in curly braces, or a block of code that starts with <code class="docutils literal notranslate"><span class="pre">:=</span></code> and ends on
a newline followed by any non-whitespace character).
If the <code class="docutils literal notranslate"><span class="pre">regular-expression</span></code> matches, the associated <code class="docutils literal notranslate"><span class="pre">code</span></code> is executed.
If multiple rules match, the longest match takes precedence. If multiple
rules match the same string, the earliest one takes precedence. There are
two special rules: the default rule <code class="docutils literal notranslate"><span class="pre">*</span></code> and the end of input rule <code class="docutils literal notranslate"><span class="pre">$</span></code>.
Default rule should always be defined, it has the lowest priority regardless
of its place in the block, and it matches any code unit (not necessarily a
valid character, see the <a class="reference internal" href="#encoding-support">encoding support</a> section). The end of input rule
should be defined if the corresponding method for
<a class="reference internal" href="#handling-the-end-of-input">handling the end of input</a> is used.
With <a class="reference internal" href="#start-conditions">start conditions</a> rules have more complex syntax.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!action</span> <span class="pre">code</span></code></dt><dd><p>An <em>action</em> binds a user-defined block of <code class="docutils literal notranslate"><span class="pre">code</span></code> to a particular place in
the generated finite state machine (in the same way as semantic actions bind
code to the final states). See the <a class="reference internal" href="#actions">actions</a> section for a full list of
predefined actions.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!directive</span> <span class="pre">;</span></code></dt><dd><p>A <em>directive</em> is one of the special predefined statements. Each directive
has a unique purpose. See the <a class="reference internal" href="#directives">directives</a> section for details.</p>
</dd>
</dl>
<section id="blocks">
<h3>Blocks<a class="headerlink" href="#blocks" title="Permalink to this headline">¶</a></h3>
<p>Block start and end markers are either <code class="docutils literal notranslate"><span class="pre">/*!re2c</span></code> and <code class="docutils literal notranslate"><span class="pre">*/</span></code>, or <code class="docutils literal notranslate"><span class="pre">%{</span></code> and
<code class="docutils literal notranslate"><span class="pre">%}</span></code> (both styles are supported). Starting from version 2.2 blocks may have
optional names that allow them to be referenced in other blocks.
There are different kinds of blocks:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">/*!re2c[:&lt;name&gt;]</span> <span class="pre">...</span> <span class="pre">*/</span></code> or <code class="docutils literal notranslate"><span class="pre">%{[:&lt;name&gt;]</span> <span class="pre">...</span> <span class="pre">%}</span></code></dt><dd><p>A <em>global block</em> contains definitions, configurations, rules and directives.
re2rust compiles regular expressions associated with each rule into a
deterministic finite automaton, encodes it in the form of conditional jumps
in the target language and replaces the block with the generated code. Names
and configurations defined in a global block are added to the global scope
and become visible to subsequent blocks. At the start of the program the
global scope is initialized with command-line <a class="reference internal" href="#options">options</a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">/*!local:re2c[:&lt;name&gt;]</span> <span class="pre">...</span> <span class="pre">*/</span></code> or <code class="docutils literal notranslate"><span class="pre">%{local[:&lt;name&gt;]</span> <span class="pre">...</span> <span class="pre">%}</span></code></dt><dd><p>A <em>local block</em> is like a global block, but the names and configurations in
it have local scope (they do not affect other blocks).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">/*!rules:re2c[:&lt;name&gt;]</span> <span class="pre">...</span> <span class="pre">*/</span></code> or <code class="docutils literal notranslate"><span class="pre">%{rules[:&lt;name&gt;]</span> <span class="pre">...</span> <span class="pre">%}</span></code></dt><dd><p>A <em>rules block</em> is like a local block, but it does not generate any code by
itself, nor does it add any definitions to the global scope – it is meant
to be reused in other blocks. This is a way of sharing code (more details in
the <a class="reference internal" href="#reusable-blocks">reusable blocks</a> section). Prior to re2rust version 2.2 rules blocks
required <code class="docutils literal notranslate"><span class="pre">-r</span> <span class="pre">--reusable</span></code> option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">/*!use:re2c[:&lt;name&gt;]</span> <span class="pre">...</span> <span class="pre">*/</span></code> or <code class="docutils literal notranslate"><span class="pre">%{use[:&lt;name&gt;]</span> <span class="pre">...</span> <span class="pre">%}</span></code></dt><dd><p>A use block that references a previously defined rules block. If the name is
specified, re2rust looks for a rules blocks with this name. Otherwise the most
recent rules block is used (either a named or an unnamed one). A use block
can add definitions, configurations and rules of its own, which are added to
those of the referenced rules block. Prior to re2rust version 2.2 use blocks
required <code class="docutils literal notranslate"><span class="pre">-r</span> <span class="pre">--reusable</span></code> option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">/*!max:re2c[:&lt;name1&gt;[:&lt;name2&gt;...]]</span> <span class="pre">...</span> <span class="pre">*/</span></code> or <code class="docutils literal notranslate"><span class="pre">%{max[:&lt;name1&gt;[:&lt;name2&gt;...]]</span> <span class="pre">...</span> <span class="pre">%}</span></code></dt><dd><p>A block that generates <code class="docutils literal notranslate"><span class="pre">YYMAXFILL</span></code> definition. An optional list of block
names specifies which blocks should be included when computing <code class="docutils literal notranslate"><span class="pre">YYMAXFILL</span></code>
value (if the list is empty, all blocks are included).
By default the generated code is a macro-definition for C
(<code class="docutils literal notranslate"><span class="pre">#define</span> <span class="pre">YYMAXFILL</span> <span class="pre">&lt;n&gt;</span></code>), or a global variable for Go
(<code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">YYMAXFILL</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">&lt;n&gt;</span></code>). It can be customized with an optional
configuration <code class="docutils literal notranslate"><span class="pre">format</span></code> that specifies a template string where <code class="docutils literal notranslate"><span class="pre">&#64;&#64;{max}</span></code>
(or <code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code> for short) is replaced with the numeric value of <code class="docutils literal notranslate"><span class="pre">YYMAXFILL</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">/*!maxnmatch:re2c[:&lt;name1&gt;[:&lt;name2&gt;...]]</span> <span class="pre">...</span> <span class="pre">*/</span></code> or <code class="docutils literal notranslate"><span class="pre">%{maxnmatch[:&lt;name1&gt;[:&lt;name2&gt;...]]</span> <span class="pre">...</span> <span class="pre">%}</span></code></dt><dd><p>A block that generates <code class="docutils literal notranslate"><span class="pre">YYMAXNMATCH</span></code> definition (it requires
<code class="docutils literal notranslate"><span class="pre">-P</span> <span class="pre">--posix-captures</span></code> option). An optional list of block names specifies
which blocks should be included when computing <code class="docutils literal notranslate"><span class="pre">YYMAXNMATCH</span></code> value (if the
list is empty, all blocks are included).
By default the generated code is a macro-definition for C
(<code class="docutils literal notranslate"><span class="pre">#define</span> <span class="pre">YYMAXNMATCH</span> <span class="pre">&lt;n&gt;</span></code>), or a global variable for Go
(<code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">YYMAXNMATCH</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">&lt;n&gt;</span></code>). It can be customized with an optional
configuration <code class="docutils literal notranslate"><span class="pre">format</span></code> that specifies a template string where <code class="docutils literal notranslate"><span class="pre">&#64;&#64;{max}</span></code>
(or <code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code> for short) is replaced with the numeric value of <code class="docutils literal notranslate"><span class="pre">YYMAXNMATCH</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">/*!stags:re2c[:&lt;name1&gt;[:&lt;name2&gt;...]]</span> <span class="pre">...</span> <span class="pre">*/</span></code>, <code class="docutils literal notranslate"><span class="pre">/*!mtags:re2c[:&lt;name1&gt;[:&lt;name2&gt;...]]</span> <span class="pre">...</span> <span class="pre">*/</span></code> or <code class="docutils literal notranslate"><span class="pre">%{stags[:&lt;name1&gt;[:&lt;name2&gt;...]]</span> <span class="pre">...</span> <span class="pre">%}</span></code>, <code class="docutils literal notranslate"><span class="pre">%{mtags[:&lt;name1&gt;[:&lt;name2&gt;...]]</span> <span class="pre">...</span> <span class="pre">%{</span></code></dt><dd><p>Blocks that specify a template piece of code that is expanded for each
s-tag/m-tag variable generated by re2rust. An optional list of block names
specifies which blocks should be included when computing the set of tag
variables (if the list is empty, all blocks are included).
There are two optional configurations: <code class="docutils literal notranslate"><span class="pre">format</span></code> and <code class="docutils literal notranslate"><span class="pre">separator</span></code>.
Configuration <code class="docutils literal notranslate"><span class="pre">format</span></code> specifies a template string where <code class="docutils literal notranslate"><span class="pre">&#64;&#64;{tag}</span></code> (or
<code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code> for short) is replaced with the name of each tag variable.
Configuration <code class="docutils literal notranslate"><span class="pre">separator</span></code> specifies a piece of code used to join the
generated <code class="docutils literal notranslate"><span class="pre">format</span></code> pieces for different tag variables.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">/*!svars:re2c[:&lt;name1&gt;[:&lt;name2&gt;...]]</span> <span class="pre">...</span> <span class="pre">*/</span></code>, <code class="docutils literal notranslate"><span class="pre">/*!mvars:re2c[:&lt;name1&gt;[:&lt;name2&gt;...]]</span> <span class="pre">...</span> <span class="pre">*/</span></code> or <code class="docutils literal notranslate"><span class="pre">%{svars[:&lt;name1&gt;[:&lt;name2&gt;...]]</span> <span class="pre">...</span> <span class="pre">%}</span></code>, <code class="docutils literal notranslate"><span class="pre">%{mvars[:&lt;name1&gt;[:&lt;name2&gt;...]]</span> <span class="pre">...</span> <span class="pre">%{</span></code></dt><dd><p>Blocks that specify a template piece of code that is expanded for each
s-tag/m-tag that is either explicitly mentioned by the rules (with
<code class="docutils literal notranslate"><span class="pre">--tags</span></code> option) or implicitly generated by re2rust (with <code class="docutils literal notranslate"><span class="pre">--captvars</span></code> or
<code class="docutils literal notranslate"><span class="pre">--posix-captvars</span></code> options). An optional list of block names specifies
which blocks should be included when computing the set of tags (if the list
is empty, all blocks are included).
There are two optional configurations: <code class="docutils literal notranslate"><span class="pre">format</span></code> and <code class="docutils literal notranslate"><span class="pre">separator</span></code>.
Configuration <code class="docutils literal notranslate"><span class="pre">format</span></code> specifies a template string where <code class="docutils literal notranslate"><span class="pre">&#64;&#64;{tag}</span></code> (or
<code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code> for short) is replaced with the name of each tag.
Configuration <code class="docutils literal notranslate"><span class="pre">separator</span></code> specifies a piece of code used to join the
generated <code class="docutils literal notranslate"><span class="pre">format</span></code> pieces for different tags.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">/*!getstate:re2c[:&lt;name1&gt;[:&lt;name2&gt;...]]</span> <span class="pre">...</span> <span class="pre">*/</span></code> or <code class="docutils literal notranslate"><span class="pre">%{getstate[:&lt;name1&gt;[:&lt;name2&gt;...]]</span> <span class="pre">...</span> <span class="pre">%}</span></code></dt><dd><p>A block that generates conditional dispatch on the lexer state (it requires
<code class="docutils literal notranslate"><span class="pre">--storable-state</span></code> option). An optional list of block names specifies
which blocks should be included in the state dispatch. The default
transition goes to the start label of the first block on the list. If the
list is empty, all blocks are included, and the default transition goes to
the first block in the file that has a start label.
This block type is incompatible with the <code class="docutils literal notranslate"><span class="pre">--loop-switch</span></code> option, as it
requires cross-block transitions that are unsupported without <code class="docutils literal notranslate"><span class="pre">goto</span></code> or
function calls.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">/*!conditions:re2c[:&lt;name1&gt;[:&lt;name2&gt;...]]</span> <span class="pre">...</span> <span class="pre">*/</span></code>, <code class="docutils literal notranslate"><span class="pre">/*!types:re2c...</span> <span class="pre">*/</span></code> or <code class="docutils literal notranslate"><span class="pre">%{conditions[:&lt;name1&gt;[:&lt;name2&gt;...]]</span> <span class="pre">...</span> <span class="pre">%}</span></code>, <code class="docutils literal notranslate"><span class="pre">%{types...</span> <span class="pre">%}</span></code></dt><dd><p>A block that generates condition enumeration (it requires <code class="docutils literal notranslate"><span class="pre">--conditions</span></code>
option). An optional list of block names specifies which blocks should be
included when computing the set of conditions (if the list is empty, all
blocks are included).
By default the generated code is an enumeration <code class="docutils literal notranslate"><span class="pre">YYCONDTYPE</span></code>. It can be
customized with optional configurations <code class="docutils literal notranslate"><span class="pre">format</span></code> and <code class="docutils literal notranslate"><span class="pre">separator</span></code>.
Configuration <code class="docutils literal notranslate"><span class="pre">format</span></code> specifies a template string where <code class="docutils literal notranslate"><span class="pre">&#64;&#64;{cond}</span></code> (or
<code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code> for short) is replaced with the name of each condition, and
<code class="docutils literal notranslate"><span class="pre">&#64;&#64;{num}</span></code> is replaced with a numeric index of that condition.
Configuration <code class="docutils literal notranslate"><span class="pre">separator</span></code> specifies a piece of code used to join the
generated <code class="docutils literal notranslate"><span class="pre">format</span></code> pieces for different conditions.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">/*!include:re2c</span> <span class="pre">&lt;file&gt;</span> <span class="pre">*/</span></code> or <code class="docutils literal notranslate"><span class="pre">%{include</span> <span class="pre">&lt;file&gt;</span> <span class="pre">%}</span></code></dt><dd><p>This block allows one to include <code class="docutils literal notranslate"><span class="pre">&lt;file&gt;</span></code>, which must be a double-quoted
file path. The contents of the file are literally substituted in place of
the block, in the same way as <code class="docutils literal notranslate"><span class="pre">#include</span></code> works in C/C++. This block can be
used together with the <code class="docutils literal notranslate"><span class="pre">--depfile</span></code> option to generate build system
dependencies on the included files.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">/*!header:re2c:on*/</span></code> or <code class="docutils literal notranslate"><span class="pre">%{header:on</span> <span class="pre">%}</span></code></dt><dd><p>This block marks the start of header file. Everything after it and up to the
following <code class="docutils literal notranslate"><span class="pre">header:off</span></code> block is processed by re2rust and written to the
header file specified with <code class="docutils literal notranslate"><span class="pre">-t</span> <span class="pre">--type-header</span></code> option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">/*!header:re2c:off*/</span></code> or <code class="docutils literal notranslate"><span class="pre">%{header:off</span> <span class="pre">%}</span></code></dt><dd><p>This block marks the end of header file started with <code class="docutils literal notranslate"><span class="pre">header:on*/</span></code> block.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">/*!ignore:re2c</span> <span class="pre">...</span> <span class="pre">*/</span></code> or <code class="docutils literal notranslate"><span class="pre">%{ignore</span> <span class="pre">...</span> <span class="pre">%}</span></code></dt><dd><p>A block which contents are ignored and removed from the output file.</p>
</dd>
</dl>
</section>
<section id="configurations">
<h3>Configurations<a class="headerlink" href="#configurations" title="Permalink to this headline">¶</a></h3>
<p>Here is a full list of configurations supported by re2rust:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">re2c:api</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:input</span></code></dt><dd><p>Same as the <code class="docutils literal notranslate"><span class="pre">--api</span></code> option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:api:sigil</span></code></dt><dd><p>Specify the marker (“sigil”) that is used for argument placeholders in the
API primitives. The default is <code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code>. A placeholder starts with sigil
followed by the argument name in curly braces. For example, if sigil is set
to <code class="docutils literal notranslate"><span class="pre">$</span></code>, then placeholders will have the form <code class="docutils literal notranslate"><span class="pre">${name}</span></code>. Single-argument
APIs may use shorthand notation without the name in braces. This option can
be overridden by options for individual API primitives, e.g.
<code class="docutils literal notranslate"><span class="pre">re2c:YYFILL&#64;len</span></code> for <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:api:style</span></code></dt><dd><p>Specify API style. Possible values are <code class="docutils literal notranslate"><span class="pre">functions</span></code> (the default for C) and
<code class="docutils literal notranslate"><span class="pre">free-form</span></code> (the default for Go and Rust).
In <code class="docutils literal notranslate"><span class="pre">functions</span></code> style API primitives are generated with an argument list in
parentheses following the name of the primitive. The arguments are provided
only for autogenerated parameters (such as the number of characters passed
to <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code>), but not for the general lexer context, so the primitives
behave more like macros in C/C++ or closures in Go and Rust.
In free-form style API primitives do not have a fixed form: they should be
defined as strings containing free-form pieces of code with interpolated
variables of the form <code class="docutils literal notranslate"><span class="pre">&#64;&#64;{var}</span></code> or <code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code> (they correspond to arguments in
function-like style).
This configuration may be overridden for individual API primitives, see for
example <code class="docutils literal notranslate"><span class="pre">re2c:YYFILL:naked</span></code> configuration for <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:bit-vectors</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:bit-vectors</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:b</span></code></dt><dd><p>Same as the <code class="docutils literal notranslate"><span class="pre">--bit-vectors</span></code> option, but can be configured on per-block
basis.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:captures</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:leftmost-captures</span></code></dt><dd><p>Same as the <code class="docutils literal notranslate"><span class="pre">--leftmost-captures</span></code> option, but can be configured on
per-block basis.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:captvars</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:leftmost-captvars</span></code></dt><dd><p>Same as the <code class="docutils literal notranslate"><span class="pre">--leftmost-captvars</span></code> option, but can be configured on
per-block basis.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:case-insensitive</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:case-insensitive</span></code></dt><dd><p>Same as the <code class="docutils literal notranslate"><span class="pre">--case-insensitive</span></code> option, but can be configured on
per-block basis.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:case-inverted</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:case-inverted</span></code></dt><dd><p>Same as the <code class="docutils literal notranslate"><span class="pre">--case-inverted</span></code> option, but can be configured on per-block
basis.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:case-ranges</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:case-ranges</span></code></dt><dd><p>Same as the <code class="docutils literal notranslate"><span class="pre">--case-ranges</span></code> option, but can be configured on per-block
basis.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:computed-gotos</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:computed-gotos</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:g</span></code></dt><dd><p>Same as the <code class="docutils literal notranslate"><span class="pre">--computed-gotos</span></code> option, but can be configured on per-block
basis.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:computed-gotos:threshold</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:cgoto:threshold</span></code></dt><dd><p>If computed <code class="docutils literal notranslate"><span class="pre">goto</span></code> is used, this configuration specifies the complexity
threshold that triggers the generation of jump tables instead of nested
<code class="docutils literal notranslate"><span class="pre">if</span></code> statements and bitmaps. The default value is <code class="docutils literal notranslate"><span class="pre">9</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:cond:abort</span></code></dt><dd><p>If set to a positive integer value, the default case in the generated
condition dispatch aborts program execution.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:cond:goto</span></code></dt><dd><p>Specifies a piece of code used for the autogenerated shortcut rules <code class="docutils literal notranslate"><span class="pre">:=&gt;</span></code>
in conditions. The default is <code class="docutils literal notranslate"><span class="pre">goto</span> <span class="pre">&#64;&#64;;</span></code>.
The <code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code> placeholder is substituted with condition name (see
configurations <code class="docutils literal notranslate"><span class="pre">re2c:api:sigil</span></code> and <code class="docutils literal notranslate"><span class="pre">re2c:cond:goto&#64;cond</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:cond:goto&#64;cond</span></code></dt><dd><p>Specifies the sigil used for argument substitution in <code class="docutils literal notranslate"><span class="pre">re2c:cond:goto</span></code>
definition. The default value is <code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code>.
Overrides the more generic <code class="docutils literal notranslate"><span class="pre">re2c:api:sigil</span></code> configuration.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:cond:divider</span></code></dt><dd><p>Defines the divider for condition blocks.
The default value is <code class="docutils literal notranslate"><span class="pre">/*</span> <span class="pre">***********************************</span> <span class="pre">*/</span></code>.
Placeholders are substituted with condition name (see <code class="docutils literal notranslate"><span class="pre">re2c:api;sigil</span></code> and
<code class="docutils literal notranslate"><span class="pre">re2c:cond:divider&#64;cond</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:cond:divider&#64;cond</span></code></dt><dd><p>Specifies the sigil used for argument substitution in <code class="docutils literal notranslate"><span class="pre">re2c:cond:divider</span></code>
definition. The default is <code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code>.
Overrides the more generic <code class="docutils literal notranslate"><span class="pre">re2c:api:sigil</span></code> configuration.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:cond:prefix</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:condprefix</span></code></dt><dd><p>Specifies the prefix used for condition labels.
The default is <code class="docutils literal notranslate"><span class="pre">yyc_</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:cond:enumprefix</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:condenumprefix</span></code></dt><dd><p>Specifies the prefix used for condition identifiers.
The default is <code class="docutils literal notranslate"><span class="pre">yyc</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:debug-output</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:debug-output</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:d</span></code></dt><dd><p>Same as the <code class="docutils literal notranslate"><span class="pre">--debug-output</span></code> option, but can be configured on per-block
basis.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:empty-class</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:empty-class</span></code></dt><dd><p>Same as the <code class="docutils literal notranslate"><span class="pre">--empty-class</span></code> option, but can be configured on per-block
basis.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:encoding:ebcdic</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:ecb</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:e</span></code></dt><dd><p>Same as the <code class="docutils literal notranslate"><span class="pre">--ebcdic</span></code> option, but can be configured on per-block basis.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:encoding:ucs2</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:wide-chars</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:w</span></code></dt><dd><p>Same as the <code class="docutils literal notranslate"><span class="pre">--ucs2</span></code> option, but can be configured on per-block basis.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:encoding:utf8</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:utf-8</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:8</span></code></dt><dd><p>Same as the <code class="docutils literal notranslate"><span class="pre">--utf8</span></code> option, but can be configured on per-block basis.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:encoding:utf16</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:utf-16</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:x</span></code></dt><dd><p>Same as the <code class="docutils literal notranslate"><span class="pre">--utf16</span></code> option, but can be configured on per-block basis.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:encoding:utf32</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:unicode</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:u</span></code></dt><dd><p>Same as the <code class="docutils literal notranslate"><span class="pre">--utf32</span></code> option, but can be configured on per-block basis.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:encoding-policy</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:encoding-policy</span></code></dt><dd><p>Same as the <code class="docutils literal notranslate"><span class="pre">--encoding-policy</span></code> option, but can be configured on per-block
basis.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:eof</span></code></dt><dd><p>Specifies the sentinel symbol used with the end-of-input rule <code class="docutils literal notranslate"><span class="pre">$</span></code>. The
default value is <code class="docutils literal notranslate"><span class="pre">-1</span></code> (<code class="docutils literal notranslate"><span class="pre">$</span></code> rule is not used). Other possible values
include all valid code units. Only decimal numbers are recognized.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:fn:sep</span></code></dt><dd><p>Specifies separator used in <code class="docutils literal notranslate"><span class="pre">YYFN</span></code> elements (defaults to semicolon).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:header</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:type-header</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:t</span></code></dt><dd><p>Specifies the name of the generated header file relative to the directory of
the output file. Same as the <code class="docutils literal notranslate"><span class="pre">--header</span></code> option except that the file path
is relative.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:indent:string</span></code></dt><dd><p>Specifies the string used for indentation. The default is a single tab
character <code class="docutils literal notranslate"><span class="pre">&quot;\t&quot;</span></code>. Indent string should contain whitespace characters only.
To disable indentation entirely, set this configuration to an empty string.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:indent:top</span></code></dt><dd><p>Specifies the minimum amount of indentation to use. The default value is
zero. The value should be a non-negative integer number.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:invert-captures</span></code></dt><dd><p>Same as the <code class="docutils literal notranslate"><span class="pre">--invert-captures</span></code> option, but can be configured on per-block
basis.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:label:prefix</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:labelprefix</span></code></dt><dd><p>Specifies the prefix used for DFA state labels. The default is <code class="docutils literal notranslate"><span class="pre">yy</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:label:start</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:startlabel</span></code></dt><dd><p>Controls the generation of a block start label. The default value is zero,
which means that the start label is generated only if it is used. An integer
value greater than zero forces the generation of start label even if it is
unused by the lexer. A string value also forces start label generation and
sets the label name to the specified string. This configuration applies only
to the current block (it is reset to default for the next block).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:label:yyFillLabel</span></code></dt><dd><p>Specifies the prefix of <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> labels used with <code class="docutils literal notranslate"><span class="pre">re2c:eof</span></code> and in
storable state mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:label:yyloop</span></code></dt><dd><p>Specifies the name of the label marking the start of the lexer loop with
<code class="docutils literal notranslate"><span class="pre">--loop-switch</span></code> option. The default is <code class="docutils literal notranslate"><span class="pre">yyloop</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:label:yyNext</span></code></dt><dd><p>Specifies the name of the optional label that follows <code class="docutils literal notranslate"><span class="pre">YYGETSTATE</span></code> switch
in storable state mode (enabled with <code class="docutils literal notranslate"><span class="pre">re2c:state:nextlabel</span></code>). The default
is <code class="docutils literal notranslate"><span class="pre">yyNext</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:lookahead</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:lookahead</span></code></dt><dd><p>Deprecated (see the deprecated <code class="docutils literal notranslate"><span class="pre">--no-lookahead</span></code> option).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:monadic</span></code></dt><dd><p>If set to non-zero, the generated lexer will use monadic notation (this
configuration is specific to Haskell).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:nested-ifs</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:nested-ifs</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:s</span></code></dt><dd><p>Same as the <code class="docutils literal notranslate"><span class="pre">--nested-ifs</span></code> option, but can be configured on per-block
basis.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:posix-captures</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:posix-captures</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:P</span></code></dt><dd><p>Same as the <code class="docutils literal notranslate"><span class="pre">--posix-captures</span></code> option, but can be configured on per-block
basis.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:posix-captvars</span></code></dt><dd><p>Same as the <code class="docutils literal notranslate"><span class="pre">--posix-captvars</span></code> option, but can be configured on per-block
basis.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:tags</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:tags</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:T</span></code></dt><dd><p>Same as the <code class="docutils literal notranslate"><span class="pre">--tags</span></code> option, but can be configured on per-block basis.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:tags:expression</span></code></dt><dd><p>Specifies the expression used for tag variables.
By default re2rust generates expressions of the form <code class="docutils literal notranslate"><span class="pre">yyt&lt;N&gt;</span></code>. This might
be inconvenient, for example if tag variables are defined as fields in a
struct. All occurrences of <code class="docutils literal notranslate"><span class="pre">&#64;&#64;{tag}</span></code> or <code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code> are replaced with the
actual tag name. For example, <code class="docutils literal notranslate"><span class="pre">re2c:tags:expression</span> <span class="pre">=</span> <span class="pre">&quot;s.&#64;&#64;&quot;;</span></code> results
in expressions of the form <code class="docutils literal notranslate"><span class="pre">s.yyt&lt;N&gt;</span></code> in the generated code.
See also <code class="docutils literal notranslate"><span class="pre">re2c:api:sigil</span></code> configuration.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:tags:negative</span></code></dt><dd><p>Specifies the constant expression that is used for negative tag value
(typically this would be <code class="docutils literal notranslate"><span class="pre">-1</span></code> if tags are integer offsets in the input
string, or null pointer if they are pointers).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:tags:prefix</span></code></dt><dd><p>Specifies the prefix for tag variable names. The default is <code class="docutils literal notranslate"><span class="pre">yyt</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:sentinel</span></code></dt><dd><p>Specifies the sentinel symbol used for the end-of-input checks (when bounds
checks are disabled with <code class="docutils literal notranslate"><span class="pre">re2c:yyfill:enable</span> <span class="pre">=</span> <span class="pre">0;</span></code> and <code class="docutils literal notranslate"><span class="pre">re2c:eof</span></code> is not
set). This configuration does not affect code generation: its purpose is to
verify that the sentinel is not allowed in the middle of a rule, and ensure
that the lexer won’t read past the end of buffer. The default value is
<cite>-1`</cite> (in that case re2rust assumes that the sentinel is zero, which is the
most common case). Only decimal numbers are recognized.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:state:abort</span></code></dt><dd><p>If set to a positive integer value, the default case in the generated
state dispatch aborts program execution, and an explicit <code class="docutils literal notranslate"><span class="pre">-1</span></code> case
contains transition to the start of the block.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:state:nextlabel</span></code></dt><dd><p>Controls if the <code class="docutils literal notranslate"><span class="pre">YYGETSTATE</span></code> switch is followed by an <code class="docutils literal notranslate"><span class="pre">yyNext</span></code> label
(the default value is zero, which corresponds to no label).
Alternatively one can use <code class="docutils literal notranslate"><span class="pre">re2c:label:start</span></code> to generate a specific start
label, or an explicit <code class="docutils literal notranslate"><span class="pre">getstate</span></code> block to generate the <code class="docutils literal notranslate"><span class="pre">YYGETSTATE</span></code>
switch separately from the lexer block.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:unsafe</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:unsafe</span></code></dt><dd><p>Same as the <code class="docutils literal notranslate"><span class="pre">--no-unsafe</span></code> option, but can be configured on per-block
basis.
If set to zero, it suppresses the generation of <code class="docutils literal notranslate"><span class="pre">unsafe</span></code> wrappers around
<code class="docutils literal notranslate"><span class="pre">YYPEEK</span></code>. The default is non-zero (wrappers are generated).
This configuration is specific to Rust.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYBACKUP</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYBACKUP</span></code></dt><dd><p>Defines generic API primitive <code class="docutils literal notranslate"><span class="pre">YYBACKUP</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYBACKUPCTX</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYBACKUPCTX</span></code></dt><dd><p>Defines generic API primitive <code class="docutils literal notranslate"><span class="pre">YYBACKUPCTX</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYCONDTYPE</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYCONDTYPE</span></code></dt><dd><p>Defines API primitive <code class="docutils literal notranslate"><span class="pre">YYCONDTYPE</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYCTYPE</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYCTYPE</span></code></dt><dd><p>Defines API primitive <code class="docutils literal notranslate"><span class="pre">YYCTYPE</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYCTXMARKER</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYCTXMARKER</span></code></dt><dd><p>Defines API primitive <code class="docutils literal notranslate"><span class="pre">YYCTXMARKER</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYCURSOR</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYCURSOR</span></code></dt><dd><p>Defines API primitive <code class="docutils literal notranslate"><span class="pre">YYCURSOR</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYDEBUG</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYDEBUG</span></code></dt><dd><p>Defines API primitive <code class="docutils literal notranslate"><span class="pre">YYDEBUG</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYFILL</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYFILL</span></code></dt><dd><p>Defines API primitive <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYFILL&#64;len</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYFILL&#64;len</span></code></dt><dd><p>Specifies the sigil used for argument substitution in <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code>
definition. Defaults to <code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code>.
Overrides the more generic <code class="docutils literal notranslate"><span class="pre">re2c:api:sigil</span></code> configuration.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYFILL:naked</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYFILL:naked</span></code></dt><dd><p>Overrides the more generic <code class="docutils literal notranslate"><span class="pre">re2c:api:style</span></code> configuration for <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code>.
Zero value corresponds to free-form API style.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYFN</span></code></dt><dd><p>Defines API primitive <code class="docutils literal notranslate"><span class="pre">YYFN</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYINPUT</span></code></dt><dd><p>Defines API primitive <code class="docutils literal notranslate"><span class="pre">YYINPUT</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYGETCOND</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYGETCONDITION</span></code></dt><dd><p>Defines API primitive <code class="docutils literal notranslate"><span class="pre">YYGETCOND</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYGETCOND:naked</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYGETCONDITION:naked</span></code></dt><dd><p>Overrides the more generic <code class="docutils literal notranslate"><span class="pre">re2c:api:style</span></code> configuration for
<code class="docutils literal notranslate"><span class="pre">YYGETCOND</span></code>. Zero value corresponds to free-form API style.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYGETSTATE</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYGETSTATE</span></code></dt><dd><p>Defines API primitive <code class="docutils literal notranslate"><span class="pre">YYGETSTATE</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYGETSTATE:naked</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYGETSTATE:naked</span></code></dt><dd><p>Overrides the more generic <code class="docutils literal notranslate"><span class="pre">re2c:api:style</span></code> configuration for
<code class="docutils literal notranslate"><span class="pre">YYGETSTATE</span></code>. Zero value corresponds to free-form API style.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYGETACCEPT</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYGETACCEPT</span></code></dt><dd><p>Defines API primitive <code class="docutils literal notranslate"><span class="pre">YYGETACCEPT</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYLESSTHAN</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYLESSTHAN</span></code></dt><dd><p>Defines generic API primitive <code class="docutils literal notranslate"><span class="pre">YYLESSTHAN</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYLIMIT</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYLIMIT</span></code></dt><dd><p>Defines API primitive <code class="docutils literal notranslate"><span class="pre">YYLIMIT</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYMARKER</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYMARKER</span></code></dt><dd><p>Defines API primitive <code class="docutils literal notranslate"><span class="pre">YYMARKER</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYMTAGN</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYMTAGN</span></code></dt><dd><p>Defines generic API primitive <code class="docutils literal notranslate"><span class="pre">YYMTAGN</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYMTAGP</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYMTAGP</span></code></dt><dd><p>Defines generic API primitive <code class="docutils literal notranslate"><span class="pre">YYMTAGP</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYPEEK</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYPEEK</span></code></dt><dd><p>Defines generic API primitive <code class="docutils literal notranslate"><span class="pre">YYPEEK</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYRESTORE</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYRESTORE</span></code></dt><dd><p>Defines generic API primitive <code class="docutils literal notranslate"><span class="pre">YYRESTORE</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYRESTORECTX</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYRESTORECTX</span></code></dt><dd><p>Defines generic API primitive <code class="docutils literal notranslate"><span class="pre">YYRESTORECTX</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYRESTORETAG</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYRESTORETAG</span></code></dt><dd><p>Defines generic API primitive <code class="docutils literal notranslate"><span class="pre">YYRESTORETAG</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYSETCOND</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYSETCONDITION</span></code></dt><dd><p>Defines API primitive <code class="docutils literal notranslate"><span class="pre">YYSETCOND</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYSETCOND&#64;cond</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYSETCONDITION&#64;cond</span></code></dt><dd><p>Specifies the sigil used for argument substitution in <code class="docutils literal notranslate"><span class="pre">YYSETCOND</span></code>
definition. The default value is <code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code>.
Overrides the more generic <code class="docutils literal notranslate"><span class="pre">re2c:api:sigil</span></code> configuration.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYSETCOND:naked</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYSETCONDITION:naked</span></code></dt><dd><p>Overrides the more generic <code class="docutils literal notranslate"><span class="pre">re2c:api:style</span></code> configuration for
<code class="docutils literal notranslate"><span class="pre">YYSETCOND</span></code>. Zero value corresponds to free-form API style.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYSETSTATE</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYSETSTATE</span></code></dt><dd><p>Defines API primitive <code class="docutils literal notranslate"><span class="pre">YYSETSTATE</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYSETSTATE&#64;state</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYSETSTATE&#64;state</span></code></dt><dd><p>Specifies the sigil used for argument substitution in <code class="docutils literal notranslate"><span class="pre">YYSETSTATE</span></code>
definition. The default value is <code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code>.
Overrides the more generic <code class="docutils literal notranslate"><span class="pre">re2c:api:sigil</span></code> configuration.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYSETSTATE:naked</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYSETSTATE:naked</span></code></dt><dd><p>Overrides the more generic <code class="docutils literal notranslate"><span class="pre">re2c:api:style</span></code> configuration for
<code class="docutils literal notranslate"><span class="pre">YYSETSTATE</span></code>. Zero value corresponds to free-form API style.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYSETACCEPT</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYSETACCEPT</span></code></dt><dd><p>Defines API primitive <code class="docutils literal notranslate"><span class="pre">YYSETACCEPT</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYSKIP</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYSKIP</span></code></dt><dd><p>Defines generic API primitive <code class="docutils literal notranslate"><span class="pre">YYSKIP</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYSHIFT</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYSHIFT</span></code></dt><dd><p>Defines generic API primitive <code class="docutils literal notranslate"><span class="pre">YYSHIFT</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYCOPYMTAG</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYCOPYMTAG</span></code></dt><dd><p>Defines generic API primitive <code class="docutils literal notranslate"><span class="pre">YYCOPYMTAG</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYCOPYSTAG</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYCOPYSTAG</span></code></dt><dd><p>Defines generic API primitive <code class="docutils literal notranslate"><span class="pre">YYCOPYSTAG</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYSHIFTMTAG</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYSHIFTMTAG</span></code></dt><dd><p>Defines generic API primitive <code class="docutils literal notranslate"><span class="pre">YYSHIFTMTAG</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYSHIFTSTAG</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYSHIFTSTAG</span></code></dt><dd><p>Defines generic API primitive <code class="docutils literal notranslate"><span class="pre">YYSHIFTSTAG</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYSTAGN</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYSTAGN</span></code></dt><dd><p>Defines generic API primitive <code class="docutils literal notranslate"><span class="pre">YYSTAGN</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:YYSTAGP</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:define:YYSTAGP</span></code></dt><dd><p>Defines generic API primitive <code class="docutils literal notranslate"><span class="pre">YYSTAGP</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:yyaccept</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:variable:yyaccept</span></code></dt><dd><p>Defines API primitive <code class="docutils literal notranslate"><span class="pre">yyaccept</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:yybm</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:variable:yybm</span></code></dt><dd><p>Defines API primitive <code class="docutils literal notranslate"><span class="pre">yybm</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:yybm:hex</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:variable:yybm:hex</span></code></dt><dd><p>If set to nonzero, bitmaps for the <code class="docutils literal notranslate"><span class="pre">--bit-vectors</span></code> option are generated
in hexadecimal format. The default is zero (bitmaps are in decimal format).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:yych</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:variable:yych</span></code></dt><dd><p>Defines API primitive <code class="docutils literal notranslate"><span class="pre">yych</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:yych:emit</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:variable:yych:emit</span></code></dt><dd><p>If set to zero, <code class="docutils literal notranslate"><span class="pre">yych</span></code> definition is not generated.
The default is non-zero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:yych:conversion</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:variable:yych:conversion</span></code></dt><dd><p>If set to non-zero, re2rust automatically generates a conversion to <code class="docutils literal notranslate"><span class="pre">YYCTYPE</span></code>
every time <code class="docutils literal notranslate"><span class="pre">yych</span></code> is read. The default is to zero (no conversion).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:yych:literals</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:variable:yych:literals</span></code></dt><dd><p>Specifies the form of literals that <code class="docutils literal notranslate"><span class="pre">yych</span></code> is matched against. Possible
values are: <code class="docutils literal notranslate"><span class="pre">char</span></code> (character literals in single quotes, non-printable
ones use escape sequences that start with backslash), <code class="docutils literal notranslate"><span class="pre">hex</span></code> (hexadecimal
integers) and <code class="docutils literal notranslate"><span class="pre">char_or_hex</span></code> (a mixture of both, character literals for
printable characters and hexadecimal integers for others).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:yyctable</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:variable:yyctable</span></code></dt><dd><p>Defines API primitive <code class="docutils literal notranslate"><span class="pre">yyctable</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:yynmatch</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:variable:yynmatch</span></code></dt><dd><p>Defines API primitive <code class="docutils literal notranslate"><span class="pre">yynmatch</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:yypmatch</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:variable:yypmatch</span></code></dt><dd><p>Defines API primitive <code class="docutils literal notranslate"><span class="pre">yypmatch</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:yytarget</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:variable:yytarget</span></code></dt><dd><p>Defines API primitive <code class="docutils literal notranslate"><span class="pre">yytarget</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:yystable</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:variable:yystable</span></code></dt><dd><p>Deprecated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:yystate</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:variable:yystate</span></code></dt><dd><p>Defines API primitive <code class="docutils literal notranslate"><span class="pre">yystate</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:yyfill</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:variable:yyfill</span></code></dt><dd><p>Defines API primitive <code class="docutils literal notranslate"><span class="pre">yyfill</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:yyfill:check</span></code></dt><dd><p>If set to zero, suppresses the generation of pre-<code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> check for the
number of input characters (the <code class="docutils literal notranslate"><span class="pre">YYLESSTHAN</span></code> definition in generic API and
the <code class="docutils literal notranslate"><span class="pre">YYLIMIT</span></code>-based comparison in C pointer API). The default is non-zero
(generate the check).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:yyfill:enable</span></code></dt><dd><p>If set to zero, suppresses the generation of <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> (together
with the check). This should be used when the whole input fits into one piece
of memory (there is no need for buffering) and the end-of-input checks do not
rely on the <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> checks (e.g. if a sentinel character is used).
Use warnings (<code class="docutils literal notranslate"><span class="pre">-W</span></code> option) and <code class="docutils literal notranslate"><span class="pre">re2c:sentinel</span></code> configuration to verify
that the generated lexer cannot read past the end of input.
The default is non-zero (<code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> is enabled).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:yyfill:parameter</span></code></dt><dd><p>If set to zero, suppresses the generation of parameter passed to <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code>.
The parameter is the minimum number of characters that must be supplied.
Defaults to non-zero (the parameter is generated).
This configuration can be overridden with <code class="docutils literal notranslate"><span class="pre">re2c:YYFILL:naked</span></code> or
<code class="docutils literal notranslate"><span class="pre">re2c:api:style</span></code>.</p>
</dd>
</dl>
</section>
<section id="regular-expressions">
<h3>Regular expressions<a class="headerlink" href="#regular-expressions" title="Permalink to this headline">¶</a></h3>
<p>re2rust uses the following syntax for regular expressions:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&quot;foo&quot;</span></code></dt><dd><p>Case-sensitive string literal.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">'foo'</span></code></dt><dd><p>Case-insensitive string literal.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">[a-xyz]</span></code>, <code class="docutils literal notranslate"><span class="pre">[^a-xyz]</span></code></dt><dd><p>Character class (possibly negated).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">.</span></code></dt><dd><p>Any character except newline.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">\</span> <span class="pre">S</span></code></dt><dd><p>Difference of character classes <code class="docutils literal notranslate"><span class="pre">R</span></code> and <code class="docutils literal notranslate"><span class="pre">S</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">R*</span></code></dt><dd><p>Zero or more occurrences of <code class="docutils literal notranslate"><span class="pre">R</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">R+</span></code></dt><dd><p>One or more occurrences of <code class="docutils literal notranslate"><span class="pre">R</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">R?</span></code></dt><dd><p>Optional <code class="docutils literal notranslate"><span class="pre">R</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">R{n}</span></code></dt><dd><p>Repetition of <code class="docutils literal notranslate"><span class="pre">R</span></code> exactly <code class="docutils literal notranslate"><span class="pre">n</span></code> times.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">R{n,}</span></code></dt><dd><p>Repetition of <code class="docutils literal notranslate"><span class="pre">R</span></code> at least <code class="docutils literal notranslate"><span class="pre">n</span></code> times.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">R{n,m}</span></code></dt><dd><p>Repetition of <code class="docutils literal notranslate"><span class="pre">R</span></code> from <code class="docutils literal notranslate"><span class="pre">n</span></code> to <code class="docutils literal notranslate"><span class="pre">m</span></code> times.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">(R)</span></code></dt><dd><p>Just <code class="docutils literal notranslate"><span class="pre">R</span></code>; parentheses are used to override precedence. If submatch
extraction is enabled, <code class="docutils literal notranslate"><span class="pre">(R)</span></code> is a capturing or a non-capturing group
depending on <code class="docutils literal notranslate"><span class="pre">--invert-captures</span></code> option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">(!R)</span></code></dt><dd><p>If submatch extraction is enabled, <code class="docutils literal notranslate"><span class="pre">(!R)</span></code> is a non-capturing or a
capturing group depending on <code class="docutils literal notranslate"><span class="pre">--invert-captures</span></code> option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">S</span></code></dt><dd><p>Concatenation: <code class="docutils literal notranslate"><span class="pre">R</span></code> followed by <code class="docutils literal notranslate"><span class="pre">S</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">|</span> <span class="pre">S</span></code></dt><dd><p>Alternative: <code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">or</span> <span class="pre">S</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">/</span> <span class="pre">S</span></code></dt><dd><p>Lookahead: <code class="docutils literal notranslate"><span class="pre">R</span></code> followed by <code class="docutils literal notranslate"><span class="pre">S</span></code>, but <code class="docutils literal notranslate"><span class="pre">S</span></code> is not consumed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Regular expression defined as <code class="docutils literal notranslate"><span class="pre">name</span></code> (or literal string <code class="docutils literal notranslate"><span class="pre">&quot;name&quot;</span></code> in
Flex compatibility mode).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{name}</span></code></dt><dd><p>Regular expression defined as <code class="docutils literal notranslate"><span class="pre">name</span></code> in Flex compatibility mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&#64;stag</span></code></dt><dd><p>An <em>s-tag</em>: saves the last input position at which <code class="docutils literal notranslate"><span class="pre">&#64;stag</span></code> matches in a
variable named <code class="docutils literal notranslate"><span class="pre">stag</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">#mtag</span></code></dt><dd><p>An <em>m-tag</em>: saves all input positions at which <code class="docutils literal notranslate"><span class="pre">#mtag</span></code> matches in a
variable named <code class="docutils literal notranslate"><span class="pre">mtag</span></code>.</p>
</dd>
</dl>
<p>Character classes and string literals may contain the following escape
sequences: <code class="docutils literal notranslate"><span class="pre">\a</span></code>, <code class="docutils literal notranslate"><span class="pre">\b</span></code>, <code class="docutils literal notranslate"><span class="pre">\f</span></code>, <code class="docutils literal notranslate"><span class="pre">\n</span></code>, <code class="docutils literal notranslate"><span class="pre">\r</span></code>, <code class="docutils literal notranslate"><span class="pre">\t</span></code>, <code class="docutils literal notranslate"><span class="pre">\v</span></code>, <code class="docutils literal notranslate"><span class="pre">\\</span></code>,
octal escapes <code class="docutils literal notranslate"><span class="pre">\ooo</span></code> and hexadecimal escapes <code class="docutils literal notranslate"><span class="pre">\xhh</span></code>, <code class="docutils literal notranslate"><span class="pre">\uhhhh</span></code> and
<code class="docutils literal notranslate"><span class="pre">\Uhhhhhhhh</span></code>.</p>
</section>
<section id="actions">
<h3>Actions<a class="headerlink" href="#actions" title="Permalink to this headline">¶</a></h3>
<p>Here is a list of predefined actions supported by re2rust:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">!entry</span> <span class="pre">code</span></code></dt><dd><p>Entry action binds a user-defined block of <code class="docutils literal notranslate"><span class="pre">code</span></code> to the start state of
the current finite state machine. If <a class="reference internal" href="#start-conditions">start conditions</a> are used, the entry
action can be set individually for each condition. This action may be used
to perform initialization, e.g. to save start location of a lexeme.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!pre_rule</span> <span class="pre">code</span></code></dt><dd><p>Pre-rule action prepends a user-defined block of <code class="docutils literal notranslate"><span class="pre">code</span></code> to semantic actions
of all rules in the current block (or condition, if <a class="reference internal" href="#start-conditions">start conditions</a> are
used). This action may be used to factor out the common part of all semantic
actions (e.g. saving the end location of a lexeme).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!post_rule</span> <span class="pre">code</span></code></dt><dd><p>Post-rule action appends a user-defined block of <code class="docutils literal notranslate"><span class="pre">code</span></code> to semantic actions
of all rules in the current block (or condition, if <a class="reference internal" href="#start-conditions">start conditions</a> are
used). This action may be used to emit trap statements that guard against
unintended control flow.</p>
</dd>
</dl>
</section>
<section id="directives">
<h3>Directives<a class="headerlink" href="#directives" title="Permalink to this headline">¶</a></h3>
<p>Here is a full list of directives supported by re2rust:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">!use:name</span> <span class="pre">;</span></code></dt><dd><p>An in-block use directive that merges a previously defined rules block with
the specified <code class="docutils literal notranslate"><span class="pre">name</span></code> into the current block. Named definitions, configurations
and rules of the referenced block are added to the current ones. Conflicts
between overlapping rules and configurations are resolved in the usual way:
the first rule takes priority, and the latest configuration overrides the
preceding ones. One exception is the special rules <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">$</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;!&gt;</span></code>
for which a block-local definition always takes priority. A use directive
can be placed anywhere inside of a block, and multiple use directives are
allowed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!include</span> <span class="pre">file</span> <span class="pre">;</span></code></dt><dd><p>This directive is the same as <code class="docutils literal notranslate"><span class="pre">include</span></code> block: it inserts <code class="docutils literal notranslate"><span class="pre">file</span></code>
contents verbatim in place of the directive.</p>
</dd>
</dl>
</section>
<section id="program-interface">
<h3>Program interface<a class="headerlink" href="#program-interface" title="Permalink to this headline">¶</a></h3>
<p>The generated code interfaces with the outer program with the help of
<em>primitives</em>, collectively referred to as the <em>API</em>.
Which primitives should be defined for a particular program depends on multiple
factors, including the complexity of regular expressions, input representation,
buffering and the use of various features. All the necessary primitives should
be defined by the user in the form of macros, functions, variables or any other
suitable form that makes the generated code syntactically and semantically
correct. re2rust does not (and cannot) check the definitions, so if anything is
missing or defined incorrectly, the generated program may have compile-time or
run-time errors.
This manual provides examples of API definitions in the most common cases.</p>
<p id="generic-api">re2rust has three API flavors that define the core set of primitives used by a
program:</p>
<dl>
<dt><strong>Simple API</strong></dt><dd><p>(<em>added in version 4.0</em>)
This is a basic API that can be enabled with <code class="docutils literal notranslate"><span class="pre">--api</span> <span class="pre">simple</span></code> option or
<code class="docutils literal notranslate"><span class="pre">re2c:api</span> <span class="pre">=</span> <span class="pre">simple</span></code> configuration. It consists of the following
primitives: <code class="docutils literal notranslate"><span class="pre">YYINPUT</span></code> (which should be defined as a sequence of code
units, e.g. a string) and <code class="docutils literal notranslate"><span class="pre">YYCURSOR</span></code>, <code class="docutils literal notranslate"><span class="pre">YYMARKER</span></code>, <code class="docutils literal notranslate"><span class="pre">YYCTXMARKER</span></code>,
<code class="docutils literal notranslate"><span class="pre">YYLIMIT</span></code> (which should be defined as indices in <code class="docutils literal notranslate"><span class="pre">YYINPUT</span></code>).</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
</dd>
<dt><strong>Record API</strong></dt><dd><p>(<em>added in version 4.0</em>)
Record API is useful in cases when lexer state must be stored in a struct.
It is enabled with <code class="docutils literal notranslate"><span class="pre">--api</span> <span class="pre">record</span></code> option or <code class="docutils literal notranslate"><span class="pre">re2c:api</span> <span class="pre">=</span> <span class="pre">record</span></code>
configuration. This API consists of a variable <code class="docutils literal notranslate"><span class="pre">yyrecord</span></code> (the
name can be overridden with <code class="docutils literal notranslate"><span class="pre">re2c:yyrecord</span></code>) that should be defined as a
struct with fields <code class="docutils literal notranslate"><span class="pre">yyinput</span></code>, <code class="docutils literal notranslate"><span class="pre">yycursor</span></code>, <code class="docutils literal notranslate"><span class="pre">yymarker</span></code>, <code class="docutils literal notranslate"><span class="pre">yyctxmarker</span></code>,
<code class="docutils literal notranslate"><span class="pre">yylimit</span></code> (only the fields used by the generated code need to be defined,
and their names can be configured).</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
</dd>
<dt><strong>Generic API</strong></dt><dd><p>This is the most flexible API and the default API for the Rust backend.
This API contains primitives for generic operations:
<code class="docutils literal notranslate"><span class="pre">YYPEEK</span></code>,
<code class="docutils literal notranslate"><span class="pre">YYSKIP</span></code>,
<code class="docutils literal notranslate"><span class="pre">YYBACKUP</span></code>,
<code class="docutils literal notranslate"><span class="pre">YYBACKUPCTX</span></code>,
<code class="docutils literal notranslate"><span class="pre">YYSTAGP</span></code>,
<code class="docutils literal notranslate"><span class="pre">YYSTAGN</span></code>,
<code class="docutils literal notranslate"><span class="pre">YYMTAGP</span></code>,
<code class="docutils literal notranslate"><span class="pre">YYMTAGN</span></code>,
<code class="docutils literal notranslate"><span class="pre">YYRESTORE</span></code>,
<code class="docutils literal notranslate"><span class="pre">YYRESTORECTX</span></code>,
<code class="docutils literal notranslate"><span class="pre">YYRESTORETAG</span></code>,
<code class="docutils literal notranslate"><span class="pre">YYSHIFT</span></code>,
<code class="docutils literal notranslate"><span class="pre">YYSHIFTSTAG</span></code>,
<code class="docutils literal notranslate"><span class="pre">YYSHIFTMTAG</span></code>,
<code class="docutils literal notranslate"><span class="pre">YYLESSTHAN</span></code>.
For example, if the input is a byte slice <code class="docutils literal notranslate"><span class="pre">buffer:</span> <span class="pre">&amp;[u8]</span></code>, variables
<code class="docutils literal notranslate"><span class="pre">cursor</span></code>, <code class="docutils literal notranslate"><span class="pre">limit</span></code>, <code class="docutils literal notranslate"><span class="pre">marker</span></code> and <code class="docutils literal notranslate"><span class="pre">ctxmarker</span></code> of type <code class="docutils literal notranslate"><span class="pre">usize</span></code>
represent input positions, and a constant <code class="docutils literal notranslate"><span class="pre">NONE</span></code> represents invalid
position, then generic API can be defined as follows:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="sd">/*!re2c</span>
<span class="sd">  re2c:YYPEEK       = &quot;*buffer.get_unchecked(cursor)&quot;;</span>
<span class="sd">  re2c:YYSKIP       = &quot;cursor += 1;&quot;;</span>
<span class="sd">  re2c:YYBACKUP     = &quot;marker = cursor;&quot;;</span>
<span class="sd">  re2c:YYRESTORE    = &quot;cursor = marker;&quot;;</span>
<span class="sd">  re2c:YYBACKUPCTX  = &quot;ctxmarker = cursor;&quot;;</span>
<span class="sd">  re2c:YYRESTORECTX = &quot;cursor = ctxmarker;&quot;;</span>
<span class="sd">  re2c:YYRESTORETAG = &quot;cursor = @@{tag};&quot;;</span>
<span class="sd">  re2c:YYLESSTHAN   = &quot;limit - cursor &lt; @@{len}&quot;;</span>
<span class="sd">  re2c:YYSTAGP      = &quot;@@{tag} = cursor;&quot;;</span>
<span class="sd">  re2c:YYSTAGN      = &quot;@@{tag} = NONE;&quot;;</span>
<span class="sd">  re2c:YYSHIFT      = &quot;cursor = (cursor as isize + @@{shift}) as usize;&quot;;</span>
<span class="sd">  re2c:YYSHIFTSTAG  = &quot;@@{tag} = (@@{tag} as isize + @@{shift}) as usize;&quot;;</span>
<span class="sd">*/</span><span class="w"></span>
</pre></div>
</div>
</dd>
</dl>
<p>Here is a full list of API primitives that may be used by the generated code in
order to interface with the outer program.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">YYCTYPE</span></code></dt><dd><p>The type of the input characters (code units).
For ASCII, EBCDIC and UTF-8 encodings it should be 1-byte unsigned integer.
For UTF-16 or UCS-2 it should be 2-byte unsigned integer. For UTF-32 it
should be 4-byte unsigned integer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYCURSOR</span></code></dt><dd><p>An l-value that stores the current input position (a pointer or an integer
offset in <code class="docutils literal notranslate"><span class="pre">YYINPUT</span></code>). Initially <code class="docutils literal notranslate"><span class="pre">YYCURSOR</span></code> should point to the first
input character, and later it is advanced by the generated code. When a rule
matches, <code class="docutils literal notranslate"><span class="pre">YYCURSOR</span></code> position is the one after the last matched character.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYLIMIT</span></code></dt><dd><p>An r-value that stores the end of input position (a pointer or an integer
offset in <code class="docutils literal notranslate"><span class="pre">YYINPUT</span></code>). Initially <code class="docutils literal notranslate"><span class="pre">YYLIMIT</span></code> should point to the position
after the last available input character. It is not changed by the
generated code. The lexer compares <code class="docutils literal notranslate"><span class="pre">YYCURSOR</span></code> to <code class="docutils literal notranslate"><span class="pre">YYLIMIT</span></code>
in order to determine if there are enough input characters left.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYMARKER</span></code></dt><dd><p>An l-value that stores the position of the latest matched rule (a pointer or
an integer offset in <code class="docutils literal notranslate"><span class="pre">YYINPUT</span></code>). It is used to restore the <code class="docutils literal notranslate"><span class="pre">YYCURSOR</span></code>
position if the longer match fails and the lexer needs to rollback.
Initialization is not needed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYCTXMARKER</span></code></dt><dd><p>An l-value that stores the position of the trailing context (a pointer or an
integer offset in <code class="docutils literal notranslate"><span class="pre">YYINPUT</span></code>). No initialization is needed. <code class="docutils literal notranslate"><span class="pre">YYCTXMARKER</span></code>
is needed only if the lookahead operator <code class="docutils literal notranslate"><span class="pre">/</span></code> is used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYFILL</span></code></dt><dd><p>A generic API primitive with one variable <code class="docutils literal notranslate"><span class="pre">len</span></code>.
<code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> should provide at least <code class="docutils literal notranslate"><span class="pre">len</span></code> more input characters or fail.
If <code class="docutils literal notranslate"><span class="pre">re2c:eof</span></code> is used, then <code class="docutils literal notranslate"><span class="pre">len</span></code> is always <code class="docutils literal notranslate"><span class="pre">1</span></code> and  <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> should
always return to the calling function; zero return value indicates success.
If <code class="docutils literal notranslate"><span class="pre">re2c:eof</span></code> is not used, then <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> return value is ignored and it
should not return on failure. The maximum value of <code class="docutils literal notranslate"><span class="pre">len</span></code> is <code class="docutils literal notranslate"><span class="pre">YYMAXFILL</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYFN</span></code></dt><dd><p>A primitive that defines function prototype in <code class="docutils literal notranslate"><span class="pre">--recursive-functions</span></code>
code model. Its value should be an array of one or more strings, where each
string contains two or three components separated by the string specified in
<code class="docutils literal notranslate"><span class="pre">re2c:fn:sep</span></code> configuration (typically a semicolon). The first array
element defines function name and return type (empty for a void function).
Subsequent elements define function arguments: first, the expression for the
argument used in function body (usually just a name); second, argument type;
third, an optional formal parameter (it defaults to the first component -
usually both the argument and the parameter are the same identifier).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYINPUT</span></code></dt><dd><p>An r-value that stores the current input character sequence (string, buffer,
etc.).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYMAXFILL</span></code></dt><dd><p>An integral constant equal to the maximum value of the argument to
<code class="docutils literal notranslate"><span class="pre">YYFILL</span></code>.  It can be generated with a <code class="docutils literal notranslate"><span class="pre">max</span></code> block.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYLESSTHAN</span></code></dt><dd><p>A generic API primitive with one variable <code class="docutils literal notranslate"><span class="pre">len</span></code>.
It should be defined as an r-value of boolean type that equals <code class="docutils literal notranslate"><span class="pre">true</span></code> if
and only if there are less than <code class="docutils literal notranslate"><span class="pre">len</span></code> input characters left.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYPEEK</span></code></dt><dd><p>A generic API primitive with no variables.
It should be defined as an r-value of type <code class="docutils literal notranslate"><span class="pre">YYCTYPE</span></code> that is equal to the
character at the current input position.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYSKIP</span></code></dt><dd><p>A generic API primitive that should advance the current input position by
one code unit.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYBACKUP</span></code></dt><dd><p>A generic API primitive that should save the current input position (to be
restored with <code class="docutils literal notranslate"><span class="pre">YYRESTORE</span></code> later).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYRESTORE</span></code></dt><dd><p>A generic API primitive that should restore the current input position to
the value saved by <code class="docutils literal notranslate"><span class="pre">YYBACKUP</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYBACKUPCTX</span></code></dt><dd><p>A generic API primitive that should save the current input position as the
position of the trailing context (to be restored with <code class="docutils literal notranslate"><span class="pre">YYRESTORECTX</span></code>
later).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYRESTORECTX</span></code></dt><dd><p>A generic API primitive that should restore the trailing context position
saved with <code class="docutils literal notranslate"><span class="pre">YYBACKUPCTX</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYRESTORETAG</span></code></dt><dd><p>A generic API primitive with one variable <code class="docutils literal notranslate"><span class="pre">tag</span></code> that should restore the
trailing context position to the value of <code class="docutils literal notranslate"><span class="pre">tag</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYSTAGP</span></code></dt><dd><p>A generic API primitive with one variable <code class="docutils literal notranslate"><span class="pre">tag</span></code>, where <code class="docutils literal notranslate"><span class="pre">tag</span></code> can be a
pointer or an offset in <code class="docutils literal notranslate"><span class="pre">YYINPUT</span></code> (see submatch extraction section for
details). <code class="docutils literal notranslate"><span class="pre">YYSTAGP</span></code> should set <code class="docutils literal notranslate"><span class="pre">tag</span></code> to the current input position.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYSTAGN</span></code></dt><dd><p>A generic API primitive with one variable <code class="docutils literal notranslate"><span class="pre">tag</span></code>, where <code class="docutils literal notranslate"><span class="pre">tag</span></code> can be a
pointer or an offset in <code class="docutils literal notranslate"><span class="pre">YYINPUT</span></code> (see submatch extraction section for
details). <code class="docutils literal notranslate"><span class="pre">YYSTAGN</span></code> should to set <code class="docutils literal notranslate"><span class="pre">tag</span></code> to a value that represents
non-existent input position.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYMTAGP</span></code></dt><dd><p>A generic API primitive with one variable <code class="docutils literal notranslate"><span class="pre">tag</span></code>.
<code class="docutils literal notranslate"><span class="pre">YYMTAGP</span></code> should append the current position to the submatch history of
<code class="docutils literal notranslate"><span class="pre">tag</span></code> (see the submatch extraction section for details.)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYMTAGN</span></code></dt><dd><p>A generic API primitive with one variable <code class="docutils literal notranslate"><span class="pre">tag</span></code>.
<code class="docutils literal notranslate"><span class="pre">YYMTAGN</span></code> should append a value that represents non-existent input
position position to the submatch history of <code class="docutils literal notranslate"><span class="pre">tag</span></code> (see the submatch
extraction section for details.)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYSHIFT</span></code></dt><dd><p>A generic API primitive with one variable <code class="docutils literal notranslate"><span class="pre">shift</span></code> that should shift the
current input position by <code class="docutils literal notranslate"><span class="pre">shift</span></code> characters (the shift value may be
negative).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYCOPYSTAG</span></code></dt><dd><p>A generic API primitive with two variables, <code class="docutils literal notranslate"><span class="pre">lhs</span></code> and <code class="docutils literal notranslate"><span class="pre">rhs</span></code> that should
copy right-hand-side s-tag variable <code class="docutils literal notranslate"><span class="pre">rhs</span></code> to the left-hand-side s-tag
variable <code class="docutils literal notranslate"><span class="pre">lhs</span></code>. For most languages this primitive has a default definition
that assigns <code class="docutils literal notranslate"><span class="pre">lhs</span></code> to <code class="docutils literal notranslate"><span class="pre">rhs</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYCOPYMTAG</span></code></dt><dd><p>A generic API primitive with two variables, <code class="docutils literal notranslate"><span class="pre">lhs</span></code> and <code class="docutils literal notranslate"><span class="pre">rhs</span></code> that should
copy right-hand-side m-tag variable <code class="docutils literal notranslate"><span class="pre">rhs</span></code> to the left-hand-side m-tag
variable <code class="docutils literal notranslate"><span class="pre">lhs</span></code>. For most languages this primitive has a default definition
that assigns <code class="docutils literal notranslate"><span class="pre">lhs</span></code> to <code class="docutils literal notranslate"><span class="pre">rhs</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYSHIFTSTAG</span></code></dt><dd><p>A generic  API primitive with two variables, <code class="docutils literal notranslate"><span class="pre">tag</span></code> and <code class="docutils literal notranslate"><span class="pre">shift</span></code> that
should shift <code class="docutils literal notranslate"><span class="pre">tag</span></code> by <code class="docutils literal notranslate"><span class="pre">shift</span></code> code units (the shift value may be
negative).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYSHIFTMTAG</span></code></dt><dd><p>A generic API primitive with two variables, <code class="docutils literal notranslate"><span class="pre">tag</span></code> and <code class="docutils literal notranslate"><span class="pre">shift</span></code> that
should shift the latest value in the history of <code class="docutils literal notranslate"><span class="pre">tag</span></code> by <code class="docutils literal notranslate"><span class="pre">shift</span></code> code
units (the shift value may be negative).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYMAXNMATCH</span></code></dt><dd><p>An integral constant equal to the maximal number of POSIX capturing groups
in a rule. It is generated with a <code class="docutils literal notranslate"><span class="pre">maxnmatch</span></code> block.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYCONDTYPE</span></code></dt><dd><p>The type of the condition enum.
It can be generated either with <code class="docutils literal notranslate"><span class="pre">conditions</span></code> block or <code class="docutils literal notranslate"><span class="pre">--header</span></code> option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYGETACCEPT</span></code></dt><dd><p>A primitive with one variable <code class="docutils literal notranslate"><span class="pre">var</span></code> that stores numeric selector of the
accepted rule. For most languages this primitive has a default definition
that reads from <code class="docutils literal notranslate"><span class="pre">var</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYSETACCEPT</span></code></dt><dd><p>A primitive with two variables: <code class="docutils literal notranslate"><span class="pre">var</span></code> (an l-value that stores numeric
selector of the accepted rule), and <code class="docutils literal notranslate"><span class="pre">val</span></code> (the value of selector). For
most languages this primitive has a default definition that assigns <code class="docutils literal notranslate"><span class="pre">var</span></code>
to <code class="docutils literal notranslate"><span class="pre">val</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYGETCOND</span></code></dt><dd><p>An r-value of type <code class="docutils literal notranslate"><span class="pre">YYCONDTYPE</span></code> that is equal to the current condition
identifier.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYSETCOND</span></code></dt><dd><p>A primitive with one variable <code class="docutils literal notranslate"><span class="pre">cond</span></code> that should set the current
condition identifier to <code class="docutils literal notranslate"><span class="pre">cond</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYGETSTATE</span></code></dt><dd><p>An r-value of integer type that is equal to the current lexer state. It
should be initialized to <code class="docutils literal notranslate"><span class="pre">-1</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYSETSTATE</span></code></dt><dd><p>A primitive with one variable <code class="docutils literal notranslate"><span class="pre">state</span></code> that should set the current lexer
state to <code class="docutils literal notranslate"><span class="pre">state</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYDEBUG</span></code></dt><dd><p>This primitive is generated only with <code class="docutils literal notranslate"><span class="pre">-d</span></code>, <code class="docutils literal notranslate"><span class="pre">--debug-output</span></code> option.
Its purpose is to add logging to the generated code (typical <code class="docutils literal notranslate"><span class="pre">YYDEBUG</span></code>
definition is a print statement). <code class="docutils literal notranslate"><span class="pre">YYDEBUG</span></code> statements are generated in
every state and have two variables: <code class="docutils literal notranslate"><span class="pre">state</span></code> (either a DFA state index or
<code class="docutils literal notranslate"><span class="pre">-1</span></code>) and <code class="docutils literal notranslate"><span class="pre">symbol</span></code> (the current input symbol).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">yyaccept</span></code></dt><dd><p>An l-value of unsigned integral type that stores the number of the latest
matched rule. User definition is necessary only with <code class="docutils literal notranslate"><span class="pre">--storable-state</span></code>
option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">yybm</span></code></dt><dd><p>A table containing compressed bitmaps for up to 8 transitions (used with
the <code class="docutils literal notranslate"><span class="pre">--bitmaps</span></code> option). The table contains 256 elements and is indexed by
1-byte code units. Each 8-bit element combines boolean values for up to 8
transitions. k-Th bit of n-th element is true iff n-th code unit is in the
range of k-th transition. The idea of this bitmap is to replace many <cite>if</cite>
branches or <cite>switch</cite> cases with one check of a single bit in the table.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">yych</span></code></dt><dd><p>An l-value of type <code class="docutils literal notranslate"><span class="pre">YYCTYPE</span></code> that stores the current input character.
User definition is necessary only with <code class="docutils literal notranslate"><span class="pre">-f</span></code> <code class="docutils literal notranslate"><span class="pre">--storable-state</span></code> option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">yyctable</span></code></dt><dd><p>Jump table generated for the initial condition dispatch (enabled with the
combination of <code class="docutils literal notranslate"><span class="pre">--conditions</span></code> and <code class="docutils literal notranslate"><span class="pre">--computed-gotos</span></code> options).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">yyfill</span></code></dt><dd><p>An l-value that stores the result of <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> call (this may be necessary
for pure functional languages, where <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> is a monadic function with
complex return value).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">yynmatch</span></code></dt><dd><p>An l-value of unsigned integral type that stores the number of POSIX
capturing groups in the matched rule.
Used only with <code class="docutils literal notranslate"><span class="pre">-P</span></code> <code class="docutils literal notranslate"><span class="pre">--posix-captures</span></code> option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">yypmatch</span></code></dt><dd><p>An array of l-values that are used to hold the tag values corresponding
to the capturing parentheses in the matching rule. Array length must be
at least <code class="docutils literal notranslate"><span class="pre">yynmatch</span> <span class="pre">*</span> <span class="pre">2</span></code> (usually <code class="docutils literal notranslate"><span class="pre">YYMAXNMATCH</span> <span class="pre">*</span> <span class="pre">2</span></code> is a good choice).
Used only with <code class="docutils literal notranslate"><span class="pre">-P</span></code> <code class="docutils literal notranslate"><span class="pre">--posix-captures</span></code> option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">yystable</span></code></dt><dd><p>Deprecated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">yystate</span></code></dt><dd><p>An l-value used with the <code class="docutils literal notranslate"><span class="pre">--loop-switch</span></code> option to store the current DFA
state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">yytarget</span></code></dt><dd><p>Jump table that contains jump targets (label addresses) for all transitions
from a state. This table is local to each state. Generation of <code class="docutils literal notranslate"><span class="pre">yytarget</span></code>
tables is enabled with <code class="docutils literal notranslate"><span class="pre">--computed-gotos</span></code> option.</p>
</dd>
</dl>
</section>
<section id="options">
<h3>Options<a class="headerlink" href="#options" title="Permalink to this headline">¶</a></h3>
<p>Some of the options have corresponding <a class="reference internal" href="#configurations">configurations</a>,
others are global and cannot be changed after re2c starts reading the input file.
Debug options generally require building re2c in debug configuration.
Internal options are useful for experimenting with the algorithms used in re2c.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">-?</span> <span class="pre">--help</span> <span class="pre">-h</span></code></dt><dd><p>Show help message.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--api</span> <span class="pre">&lt;simple</span> <span class="pre">|</span> <span class="pre">record</span> <span class="pre">|</span> <span class="pre">generic&gt;</span></code></dt><dd><p>Specify the API used by the generated code to interface with used-defined
code. Option <code class="docutils literal notranslate"><span class="pre">simple</span></code> shold be used in simple cases when there’s no need
for buffer refilling and storing lexer state. Option <code class="docutils literal notranslate"><span class="pre">record</span></code> should be
used when lexer state needs to be stored in a record (struct, class, etc.).
Option <code class="docutils literal notranslate"><span class="pre">generic</span></code> should be used in complex cases when the other two APIs
are not flexible enough.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--bit-vectors</span> <span class="pre">-b</span></code></dt><dd><p>Optimize conditional jumps using bit masks.
This option implies <code class="docutils literal notranslate"><span class="pre">--nested-ifs</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--captures</span></code>, <code class="docutils literal notranslate"><span class="pre">--leftmost-captures</span></code></dt><dd><p>Enable submatch extraction with leftmost greedy capturing groups. The result
is collected into an array <code class="docutils literal notranslate"><span class="pre">yybmatch</span></code> of capacity <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">YYMAXNMATCH</span></code>, and
<code class="docutils literal notranslate"><span class="pre">yynmatch</span></code> is set to the number of groups for the matching rule.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--captvars</span></code>, <code class="docutils literal notranslate"><span class="pre">--leftmost-captvars</span></code></dt><dd><p>Enable submatch extraction with leftmost greedy capturing groups. The result
is collected into variables <code class="docutils literal notranslate"><span class="pre">yytl&lt;k&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">yytr&lt;k&gt;</span></code> for <code class="docutils literal notranslate"><span class="pre">k</span></code>-th capturing
group.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--case-insensitive</span></code></dt><dd><p>Treat single-quoted and double-quoted strings as case-insensitive.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--case-inverted</span></code></dt><dd><p>Invert the meaning of single-quoted and double-quoted strings:
treat single-quoted strings as case-sensitive and double-quoted strings
as case-insensitive.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--case-ranges</span></code></dt><dd><p>Collapse consecutive cases in a switch statements into a range of the form
<code class="docutils literal notranslate"><span class="pre">low</span> <span class="pre">...</span> <span class="pre">high</span></code>. This syntax is a C/C++ language extension that is
supported by compilers like GCC, Clang and Tcc. The main advantage over
using single cases is smaller generated code and faster generation time,
although for some compilers like Tcc it also results in smaller binary size.
This option is supported only for C.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--computed-gotos</span> <span class="pre">-g</span></code></dt><dd><p>Optimize conditional jumps using non-standard “computed goto” extension
(which must be supported by the compiler). re2rust generates jump tables
only in complex cases with a lot of conditional branches. Complexity
threshold can be configured with <code class="docutils literal notranslate"><span class="pre">cgoto:threshold</span></code> configuration. This
option implies <code class="docutils literal notranslate"><span class="pre">--bit-vectors</span></code>. It is supported only for C.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--conditions</span> <span class="pre">--start-conditions</span> <span class="pre">-c</span></code></dt><dd><p>Enable support of Flex-like “conditions”: multiple interrelated lexers
within one block. This is an alternative to manually specifying different
re2rust blocks connected with <code class="docutils literal notranslate"><span class="pre">goto</span></code> or function calls.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--depfile</span> <span class="pre">FILE</span></code></dt><dd><p>Write dependency information to <code class="docutils literal notranslate"><span class="pre">FILE</span></code> in the form of a Makefile rule
<code class="docutils literal notranslate"><span class="pre">&lt;output-file&gt;</span> <span class="pre">:</span> <span class="pre">&lt;input-file&gt;</span> <span class="pre">[include-file</span> <span class="pre">...]</span></code>. This allows one to
track build dependencies in the presence of <code class="docutils literal notranslate"><span class="pre">include</span></code> blocks/directives,
so that updating include files triggers regeneration of the output file.
This option depends on the <code class="docutils literal notranslate"><span class="pre">--output</span></code> option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--ebcdic</span> <span class="pre">--ecb</span> <span class="pre">-e</span></code></dt><dd><p>Generate a lexer that reads input in EBCDIC encoding. re2rust assumes that
the character range is 0 – 0xFF and character size is 1 byte.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--empty-class</span> <span class="pre">&lt;match-empty</span> <span class="pre">|</span> <span class="pre">match-none</span> <span class="pre">|</span> <span class="pre">error&gt;</span></code></dt><dd><p>Define the way re2rust treats empty character classes. With <code class="docutils literal notranslate"><span class="pre">match-empty</span></code>
(the default) empty class matches empty input (which is illogical, but
backwards-compatible). With <code class="docutils literal notranslate"><span class="pre">match-none</span></code> empty class always fails to match.
With <code class="docutils literal notranslate"><span class="pre">error</span></code> empty class raises a compilation error.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--encoding-policy</span> <span class="pre">&lt;fail</span> <span class="pre">|</span> <span class="pre">substitute</span> <span class="pre">|</span> <span class="pre">ignore&gt;</span></code></dt><dd><p>Define the way re2rust treats Unicode surrogates.
With <code class="docutils literal notranslate"><span class="pre">fail</span></code> re2rust aborts with an error when a surrogate is encountered.
With <code class="docutils literal notranslate"><span class="pre">substitute</span></code> re2rust silently replaces surrogates with the error code
point 0xFFFD. With <code class="docutils literal notranslate"><span class="pre">ignore</span></code> (the default) re2rust treats surrogates as
normal code points. The Unicode standard says that standalone surrogates
are invalid, but real-world libraries and programs behave in different ways.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--flex-syntax</span> <span class="pre">-F</span></code></dt><dd><p>Partial support for Flex syntax: in this mode named definitions don’t need
the equal sign and the terminating semicolon, and when used they must be
surrounded with curly braces. Names without curly braces are treated as
double-quoted strings.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--goto-label</span></code></dt><dd><p>Use “goto/label” code model: encode DFA in form of labeled code blocks
connected with <code class="docutils literal notranslate"><span class="pre">goto</span></code> transitions across blocks. This is only supported
for languages that have a <code class="docutils literal notranslate"><span class="pre">goto</span></code> statement.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--header</span> <span class="pre">--type-header</span> <span class="pre">-t</span> <span class="pre">HEADER</span></code></dt><dd><p>Generate a <code class="docutils literal notranslate"><span class="pre">HEADER</span></code> file. The contents of the file can be specified using
special blocks <code class="docutils literal notranslate"><span class="pre">header:on</span></code> and <code class="docutils literal notranslate"><span class="pre">header:off</span></code>. If conditions are used, the
generated header will have a condition enum automatically appended to it
(unless there is an explicit <code class="docutils literal notranslate"><span class="pre">conditions</span></code> block).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-I</span> <span class="pre">PATH</span></code></dt><dd><p>Add <code class="docutils literal notranslate"><span class="pre">PATH</span></code> to the list of locations which are used when searching for
include files. This option is useful in combination with <code class="docutils literal notranslate"><span class="pre">include</span></code> block
or directive. re2rust looks for <code class="docutils literal notranslate"><span class="pre">FILE</span></code> in the directory of the parent file
and in the include locations specified with <code class="docutils literal notranslate"><span class="pre">-I</span></code> option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--input</span> <span class="pre">&lt;default</span> <span class="pre">|</span> <span class="pre">custom&gt;</span></code></dt><dd><p>Deprecated alias for <code class="docutils literal notranslate"><span class="pre">--api</span></code>. Option <code class="docutils literal notranslate"><span class="pre">default</span></code> corresponds to <code class="docutils literal notranslate"><span class="pre">simple</span></code>
(it is indeed the default for most backends, but not for all). Option
<code class="docutils literal notranslate"><span class="pre">custom</span></code> corresponds to <code class="docutils literal notranslate"><span class="pre">generic</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--input-encoding</span> <span class="pre">&lt;ascii</span> <span class="pre">|</span> <span class="pre">utf8&gt;</span></code></dt><dd><p>Specify the way re2rust parses regular expressions.
With <code class="docutils literal notranslate"><span class="pre">ascii</span></code> (the default) re2rust handles input as ASCII-encoded: any
sequence of code units is a sequence of standalone 1-byte characters.
With <code class="docutils literal notranslate"><span class="pre">utf8</span></code> re2rust handles input as UTF8-encoded and recognizes multibyte
characters.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--invert-captures</span></code></dt><dd><p>Invert the meaning of capturing and non-capturing groups. By default
<code class="docutils literal notranslate"><span class="pre">(...)</span></code> is capturing and <code class="docutils literal notranslate"><span class="pre">(!</span> <span class="pre">...)</span></code> is non-capturing. With this option
<code class="docutils literal notranslate"><span class="pre">(!</span> <span class="pre">...)</span></code> is capturing and <code class="docutils literal notranslate"><span class="pre">(...)</span></code> is non-capturing.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--lang</span> <span class="pre">&lt;none</span> <span class="pre">|</span> <span class="pre">c</span> <span class="pre">|</span> <span class="pre">d</span> <span class="pre">|</span> <span class="pre">go</span> <span class="pre">|</span> <span class="pre">haskell</span> <span class="pre">|</span> <span class="pre">java</span> <span class="pre">|</span> <span class="pre">js</span> <span class="pre">|</span> <span class="pre">ocaml</span> <span class="pre">|</span> <span class="pre">python</span> <span class="pre">|</span> <span class="pre">rust</span> <span class="pre">|</span> <span class="pre">v</span> <span class="pre">|</span> <span class="pre">zig&gt;</span></code></dt><dd><p>Specify the target language. Supported languages are C, D, Go, Haskell,
Java, JS, OCaml, Python, Rust, V, Zig (more languages can be added via
user-defined syntax files, see the <code class="docutils literal notranslate"><span class="pre">--syntax</span></code> option). Option <code class="docutils literal notranslate"><span class="pre">none</span></code>
disables default suntax configs, so that the target language is undefined.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--location-format</span> <span class="pre">&lt;gnu</span> <span class="pre">|</span> <span class="pre">msvc&gt;</span></code></dt><dd><p>Specify location format in messages.
With <code class="docutils literal notranslate"><span class="pre">gnu</span></code> locations are printed as ‘filename:line:column: …’.
With <code class="docutils literal notranslate"><span class="pre">msvc</span></code> locations are printed as ‘filename(line,column) …’.
The default is <code class="docutils literal notranslate"><span class="pre">gnu</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--loop-switch</span></code></dt><dd><p>Use “loop/switch” code model: encode DFA in form of a loop over a switch
statement, where individual states are switch cases. State is stored in a
variable <code class="docutils literal notranslate"><span class="pre">yystate</span></code>. Transitions between states update <code class="docutils literal notranslate"><span class="pre">yystate</span></code> to the
case label of the destination state and continue execution to the head of
the loop.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--nested-ifs</span> <span class="pre">-s</span></code></dt><dd><p>Use nested <code class="docutils literal notranslate"><span class="pre">if</span></code> statements instead of <code class="docutils literal notranslate"><span class="pre">switch</span></code> statements in conditional
jumps. This usually results in more efficient code with non-optimizing
compilers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--no-debug-info</span> <span class="pre">-i</span></code></dt><dd><p>Do not output line directives. This may be useful when the generated code is
stored in a version control system (to avoid huge autogenerated diffs on
small changes).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--no-generation-date</span></code></dt><dd><p>Suppress date output in the generated file.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--no-version</span></code></dt><dd><p>Suppress version output in the generated file.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--no-unsafe</span></code></dt><dd><p>Do not generate <code class="docutils literal notranslate"><span class="pre">unsafe</span></code> wrapper over <code class="docutils literal notranslate"><span class="pre">YYPEEK</span></code> (this option is specific
to Rust). For performance reasons <code class="docutils literal notranslate"><span class="pre">YYPEEK</span></code> should avoid bounds-checking,
as the lexer already performs end-of-input checks in a more efficient way.
The user may choose to provide a safe <code class="docutils literal notranslate"><span class="pre">YYPEEK</span></code> definition, or a definition
that is unsafe only in release builds, in which case the <code class="docutils literal notranslate"><span class="pre">--no-unsafe</span></code>
option helps to avoid warnings about redundant <code class="docutils literal notranslate"><span class="pre">unsafe</span></code> blocks.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--output</span> <span class="pre">-o</span> <span class="pre">OUTPUT</span></code></dt><dd><p>Specify the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> file.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--posix-captures</span></code>, <code class="docutils literal notranslate"><span class="pre">-P</span></code></dt><dd><p>Enable submatch extraction with POSIX-style capturing groups. The result
is collected into an array <code class="docutils literal notranslate"><span class="pre">yybmatch</span></code> of capacity <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">YYMAXNMATCH</span></code>, and
<code class="docutils literal notranslate"><span class="pre">yynmatch</span></code> is set to the number of groups for the matching rule.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--posix-captvars</span></code></dt><dd><p>Enable submatch extraction with POSIX-style capturing groups. The result
is collected into variables <code class="docutils literal notranslate"><span class="pre">yytl&lt;k&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">yytr&lt;k&gt;</span></code> for <code class="docutils literal notranslate"><span class="pre">k</span></code>-th capturing
group.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--recursive-functions</span></code></dt><dd><p>Use code model based on co-recursive functions, where each DFA state is a
separate function that may call other state-functions or itself.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--reusable</span> <span class="pre">-r</span></code></dt><dd><p>Deprecated since version 2.2 (reusable blocks are allowed by default now).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--skeleton</span> <span class="pre">-S</span></code></dt><dd><p>Ignore user-defined interface code and generate a self-contained “skeleton”
program. Additionally, generate input files with strings derived from the
regular grammar and compressed match results that are used to verify
“skeleton” behavior on all inputs. This option is useful for finding bugs
in optimizations and code generation. This option is supported only for C.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--storable-state</span> <span class="pre">-f</span></code></dt><dd><p>Generate a lexer which can store its inner state.
This is useful in push-model lexers which are stopped by an outer program
when there is not enough input, and then resumed when more input becomes
available. In this mode users should additionally define <code class="docutils literal notranslate"><span class="pre">YYGETSTATE</span></code>
and <code class="docutils literal notranslate"><span class="pre">YYSETSTATE</span></code> primitives, and variables <code class="docutils literal notranslate"><span class="pre">yych</span></code>, <code class="docutils literal notranslate"><span class="pre">yyaccept</span></code> and
<code class="docutils literal notranslate"><span class="pre">state</span></code> should be part of the stored lexer state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--syntax</span> <span class="pre">FILE</span></code></dt><dd><p>Load configurations from the specified <code class="docutils literal notranslate"><span class="pre">FILE</span></code> and apply them on top of the
default syntax file. Note that <code class="docutils literal notranslate"><span class="pre">FILE</span></code> can define only a few configurations
(if it’s used to amend the default syntax file), or it can define a whole
new language backend (in the latter case it is recommended to use
<code class="docutils literal notranslate"><span class="pre">--lang</span> <span class="pre">none</span></code> option).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--tags</span> <span class="pre">-T</span></code></dt><dd><p>Enable submatch extraction with tags.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--ucs2</span> <span class="pre">--wide-chars</span> <span class="pre">-w</span></code></dt><dd><p>Generate a lexer that reads UCS2-encoded input. re2rust assumes that the
character range is 0 – 0xFFFF and character size is 2 bytes.
This option implies <code class="docutils literal notranslate"><span class="pre">--nested-ifs</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--utf8</span> <span class="pre">--utf-8</span> <span class="pre">-8</span></code></dt><dd><p>Generate a lexer that reads input in UTF-8 encoding. re2rust assumes that the
character range is 0 – 0x10FFFF and character size is 1 byte.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--utf16</span> <span class="pre">--utf-16</span> <span class="pre">-x</span></code></dt><dd><p>Generate a lexer that reads UTF16-encoded input. re2rust assumes that the
character range is 0 – 0x10FFFF and character size is 2 bytes.
This option implies <code class="docutils literal notranslate"><span class="pre">--nested-ifs</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--utf32</span> <span class="pre">--unicode</span> <span class="pre">-u</span></code></dt><dd><p>Generate a lexer that reads UTF32-encoded input. re2rust assumes that the
character range is 0 – 0x10FFFF and character size is 4 bytes.
This option implies <code class="docutils literal notranslate"><span class="pre">--nested-ifs</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--verbose</span></code></dt><dd><p>Output a short message in case of success.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--vernum</span> <span class="pre">-V</span></code></dt><dd><p>Show version information in <code class="docutils literal notranslate"><span class="pre">MMmmpp</span></code> format (major, minor, patch).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--version</span> <span class="pre">-v</span></code></dt><dd><p>Show version information.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--single-pass</span> <span class="pre">-1</span></code></dt><dd><p>Deprecated. Does nothing (single pass is the default now).</p>
</dd>
</dl>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">--debug-output</span> <span class="pre">-d</span></code></dt><dd><p>Emit <code class="docutils literal notranslate"><span class="pre">YYDEBUG</span></code> invocations in the generated code. This is useful to trace
lexer execution.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--dump-adfa</span></code></dt><dd><p>Debug option: output DFA after tunneling (in .dot format).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--dump-cfg</span></code></dt><dd><p>Debug option: output control flow graph of tag variables (in .dot format).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--dump-closure-stats</span></code></dt><dd><p>Debug option: output statistics on the number of states in closure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--dump-dfa-det</span></code></dt><dd><p>Debug option: output DFA immediately after determinization (in .dot format).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--dump-dfa-min</span></code></dt><dd><p>Debug option: output DFA after minimization (in .dot format).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--dump-dfa-tagopt</span></code></dt><dd><p>Debug option: output DFA after tag optimizations (in .dot format).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--dump-dfa-tree</span></code></dt><dd><p>Debug option: output DFA under construction with states represented as tag
history trees (in .dot format).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--dump-dfa-raw</span></code></dt><dd><p>Debug option: output DFA under construction with expanded state-sets
(in .dot format).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--dump-interf</span></code></dt><dd><p>Debug option: output interference table produced by liveness analysis of tag
variables.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--dump-nfa</span></code></dt><dd><p>Debug option: output NFA (in .dot format).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--emit-dot</span> <span class="pre">-D</span></code></dt><dd><p>Instead of normal output generate lexer graph in .dot format.
The output can be converted to an image with the help of Graphviz
(e.g. something like <code class="docutils literal notranslate"><span class="pre">dot</span> <span class="pre">-Tpng</span> <span class="pre">-odfa.png</span> <span class="pre">dfa.dot</span></code>).</p>
</dd>
</dl>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">--dfa-minimization</span> <span class="pre">&lt;moore</span> <span class="pre">|</span> <span class="pre">table&gt;</span></code></dt><dd><p>Internal option: DFA minimization algorithm used by re2rust. The <code class="docutils literal notranslate"><span class="pre">moore</span></code>
option is the Moore algorithm (it is the default). The <code class="docutils literal notranslate"><span class="pre">table</span></code> option is
the “table filling” algorithm. Both algorithms should produce the same DFA
up to states relabeling; table filling is simpler and much slower and serves
as a reference implementation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--eager-skip</span></code></dt><dd><p>Internal option: make the generated lexer advance the input position
eagerly – immediately after reading the input symbol. This changes the
default behavior when the input position is advanced lazily – after
transition to the next state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--no-lookahead</span></code></dt><dd><p>Internal option, deprecated.
It used to enable TDFA(0) algorithm. Unlike TDFA(1), TDFA(0) algorithm does
not use one-symbol lookahead. It applies register operations to the incoming
transitions rather than the outgoing ones. Benchmarks showed that TDFA(0)
algorithm is less efficient than TDFA(1).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--no-optimize-tags</span></code></dt><dd><p>Internal option: suppress optimization of tag variables (useful for
debugging).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--posix-closure</span> <span class="pre">&lt;gor1</span> <span class="pre">|</span> <span class="pre">gtop&gt;</span></code></dt><dd><p>Internal option: specify shortest-path algorithm used for the construction of
epsilon-closure with POSIX disambiguation semantics: <code class="docutils literal notranslate"><span class="pre">gor1</span></code> (the default)
stands for Goldberg-Radzik algorithm, and <code class="docutils literal notranslate"><span class="pre">gtop</span></code> stands for “global
topological order” algorithm.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--posix-prectable</span> <span class="pre">&lt;complex</span> <span class="pre">|</span> <span class="pre">naive&gt;</span></code></dt><dd><p>Internal option: specify the algorithm used to compute POSIX precedence
table. The <code class="docutils literal notranslate"><span class="pre">complex</span></code> algorithm computes precedence table in one traversal
of tag history tree and has quadratic complexity in the number of TNFA
states; it is the default. The <code class="docutils literal notranslate"><span class="pre">naive</span></code> algorithm has worst-case cubic
complexity in the number of TNFA states, but it is much simpler than
<code class="docutils literal notranslate"><span class="pre">complex</span></code> and may be slightly faster in non-pathological cases.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--stadfa</span></code></dt><dd><p>Internal option, deprecated.
It used to enable staDFA algorithm, which differs from TDFA in that register
operations are placed in states rather than on transitions. Benchmarks
showed that staDFA algorithm is less efficient than TDFA.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--fixed-tags</span> <span class="pre">&lt;none</span> <span class="pre">|</span> <span class="pre">toplevel</span> <span class="pre">|</span> <span class="pre">all&gt;</span></code></dt><dd><p>Internal option:
specify whether the fixed-tag optimization should be applied to all tags
(<code class="docutils literal notranslate"><span class="pre">all</span></code>), none of them (<code class="docutils literal notranslate"><span class="pre">none</span></code>), or only those in toplevel concatenation
(<code class="docutils literal notranslate"><span class="pre">toplevel</span></code>). The default is <code class="docutils literal notranslate"><span class="pre">all</span></code>.
“Fixed” tags are those that are located within a fixed distance to some
other tag (called “base”). In such cases only the base tag needs to be
tracked, and the value of the fixed tag can be computed as the value of the
base tag plus a static offset. For tags that are under alternative or
repetition it is also necessary to check if the base tag has a no-match
value (in that case fixed tag should also be set to no-match, disregarding
the offset). For tags in top-level concatenation the check is not needed,
because they always match.</p>
</dd>
</dl>
</section>
<section id="warnings">
<h3>Warnings<a class="headerlink" href="#warnings" title="Permalink to this headline">¶</a></h3>
<p>See the <a class="reference internal" href="basics/warnings/warnings.html#detailed-warnings"><span class="std std-ref">warnings page</span></a> for detailed descriptions of individual warnings.</p>
<p>Warnings can be invividually enabled, disabled and turned into an error.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">-W</span></code></dt><dd><p>Turn on all warnings.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-Werror</span></code></dt><dd><p>Turn warnings into errors. Note that this option alone
doesn’t turn on any warnings; it only affects those warnings that have
been turned on so far or will be turned on later.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-W&lt;warning&gt;</span></code></dt><dd><p>Turn on <code class="docutils literal notranslate"><span class="pre">warning</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-Wno-&lt;warning&gt;</span></code></dt><dd><p>Turn off <code class="docutils literal notranslate"><span class="pre">warning</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-Werror-&lt;warning&gt;</span></code></dt><dd><p>Turn on <code class="docutils literal notranslate"><span class="pre">warning</span></code> and treat it as an error (this implies <code class="docutils literal notranslate"><span class="pre">-W&lt;warning&gt;</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-Wno-error-&lt;warning&gt;</span></code></dt><dd><p>Don’t treat this particular <code class="docutils literal notranslate"><span class="pre">warning</span></code> as an error. This doesn’t turn off
the warning itself.</p>
</dd>
</dl>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">-Wcondition-order</span></code></dt><dd><p>Warn if the generated program makes implicit assumptions about condition
numbering. One should use either <code class="docutils literal notranslate"><span class="pre">--header</span></code> option or <code class="docutils literal notranslate"><span class="pre">conditions</span></code>
block to generate a mapping of condition names to numbers and then use the
autogenerated condition names.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-Wempty-character-class</span></code></dt><dd><p>Warn if a regular expression contains an empty character class. Trying to
match an empty character class makes no sense: it should always fail.
However, for backwards compatibility reasons re2rust permits empty character
classes and treats them as empty strings. Use the <code class="docutils literal notranslate"><span class="pre">--empty-class</span></code> option
to change the default behavior.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-Wmatch-empty-string</span></code></dt><dd><p>Warn if a rule is nullable (matches an empty string).
If the lexer runs in a loop and the empty match is unintentional, the lexer
may unexpectedly hang in an infinite loop.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-Wswapped-range</span></code></dt><dd><p>Warn if the lower bound of a range is greater than its upper bound. The
default behavior is to silently swap the range bounds.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-Wundefined-control-flow</span></code></dt><dd><p>Warn if some input strings cause undefined control flow in the lexer (the
faulty patterns are reported). This is a dangerous and common mistake. It
can be easily fixed by adding the default rule <code class="docutils literal notranslate"><span class="pre">*</span></code> which has the lowest
priority, matches any code unit, and always consumes a single code unit.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-Wunreachable-rules</span></code></dt><dd><p>Warn about rules that are shadowed by other rules and will never match.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-Wuseless-escape</span></code></dt><dd><p>Warn if a symbol is escaped when it shouldn’t be.
By default, re2rust silently ignores such escapes, but this may as well
indicate a typo or an error in the escape sequence.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-Wnondeterministic-tags</span></code></dt><dd><p>Warn if a tag has <code class="docutils literal notranslate"><span class="pre">n</span></code>-th degree of nondeterminism, where <code class="docutils literal notranslate"><span class="pre">n</span></code> is greater
than 1.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-Wsentinel-in-midrule</span></code></dt><dd><p>Warn if the sentinel symbol occurs in the middle of a rule — this may
cause reads past the end of buffer, crashes or memory corruption in the
generated lexer. This warning is only applicable if the sentinel method of
checking for the end of input is used.
It is set to an error if <code class="docutils literal notranslate"><span class="pre">re2c:sentinel</span></code> configuration is used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-Wundefined-syntax-config</span></code></dt><dd><p>Warn if the syntax file specified with <code class="docutils literal notranslate"><span class="pre">--syntax</span></code> option is missing
definitions of some configurations. This helps to maintain user-defined
syntax files: if a new release adds configurations, old syntax file will
raise a warning, and the user will be notified. If some configurations are
unused and do not need a definition, they should be explicitly set to
<code class="docutils literal notranslate"><span class="pre">&lt;undefined&gt;</span></code>.</p>
</dd>
</dl>
</section>
<section id="syntax-files">
<h3>Syntax files<a class="headerlink" href="#syntax-files" title="Permalink to this headline">¶</a></h3>
<p>Support for different languages in re2c is based on the idea of <em>syntax files</em>.
A syntax file is a configuration file that defines syntax of the target language
– not the whole language, but a small part of it that is used by the generated
code. Syntax files make re2c very flexible, but they should not be used as a
replacement for <code class="docutils literal notranslate"><span class="pre">re2c:</span></code> configurations: their purpose is to define syntax of
the target language, not to customize one particular lexer. All supported
languages have default syntax files that are part of the distribution (see
<code class="docutils literal notranslate"><span class="pre">include/syntax</span></code> subdirectory); they are also embedded in the re2rust binary.
Users may provide a custom syntax file that overrides a few configurations for
one of supported languages, or they may choose to redefine all configurations
(in that case <code class="docutils literal notranslate"><span class="pre">--lang</span> <span class="pre">none</span></code> option should be used).
Syntax files contain configurations of four different kinds: feature lists,
language configurations, inplace configurations and code templates.</p>
<p><strong>Feature lists</strong></p>
<blockquote>
<div><p>A few list configurations define various features supported by a given
backend, so that re2rust may give a clear error if the user tries to enable an
unsupported feature:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">supported_apis</span></code></dt><dd><p>A list of supported APIs with possible elements <code class="docutils literal notranslate"><span class="pre">simple</span></code>, <code class="docutils literal notranslate"><span class="pre">record</span></code>,
<code class="docutils literal notranslate"><span class="pre">generic</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">supported_api_styles</span></code></dt><dd><p>A list of supported API styles with possible elements <code class="docutils literal notranslate"><span class="pre">functions</span></code>,
<code class="docutils literal notranslate"><span class="pre">free-form</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">supported_code_models</span></code></dt><dd><p>A list of supported code models with possible elements <code class="docutils literal notranslate"><span class="pre">goto-label</span></code>,
<code class="docutils literal notranslate"><span class="pre">loop-switch</span></code>, <code class="docutils literal notranslate"><span class="pre">recursive-functions</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">supported_targets</span></code></dt><dd><p>A list of supported codegen targets with possible elements <code class="docutils literal notranslate"><span class="pre">code</span></code>,
<code class="docutils literal notranslate"><span class="pre">dot</span></code>, <code class="docutils literal notranslate"><span class="pre">skeleton</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">supported_features</span></code></dt><dd><p>A list of supported features with possible elements <code class="docutils literal notranslate"><span class="pre">nested-ifs</span></code>,
<code class="docutils literal notranslate"><span class="pre">bitmaps</span></code>, <code class="docutils literal notranslate"><span class="pre">computed-gotos</span></code>, <code class="docutils literal notranslate"><span class="pre">case-ranges</span></code>, <code class="docutils literal notranslate"><span class="pre">monadic</span></code>, <code class="docutils literal notranslate"><span class="pre">unsafe</span></code>,
<code class="docutils literal notranslate"><span class="pre">tags</span></code>, <code class="docutils literal notranslate"><span class="pre">captures</span></code>, <code class="docutils literal notranslate"><span class="pre">captvars</span></code>.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>Language configurations</strong></p>
<blockquote>
<div><p>A few boolean configurations describe features of the target language that
affect re2rust parser and code generator:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">semicolons</span></code></dt><dd><p>Non-zero if the language uses semicolons after statements.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">backtick_quoted_strings</span></code></dt><dd><p>Non-zero if the language has backtick-quoted strings.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">single_quoted_strings</span></code></dt><dd><p>Non-zero if the language has single-quoted strings.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">indentation_sensitive</span></code></dt><dd><p>Non-zero if the language is indentation sensitive.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wrap_blocks_in_braces</span></code></dt><dd><p>Non-zero if compound statements must be wrapped in curly braces.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>Inplace configurations</strong></p>
<blockquote>
<div><p>Syntax files define initial values of all <code class="docutils literal notranslate"><span class="pre">re2c:</span></code> configurations, as they
may differ for different languages. See configurations section for a full list
of all inplace configurations and their meaning.</p>
</div></blockquote>
<p><strong>Code templates</strong></p>
<blockquote>
<div><p>Code templates define syntax of the target language. They are written in a
simple domain-specific language with the following formal grammar:</p>
<div class="highlight-bnf notranslate"><div class="highlight"><pre><span></span>code-template ::
      name &#39;=&#39; code-exprs &#39;;&#39;
    | CODE_TEMPLATE &#39;;&#39;
    | &#39;<span class="p">&lt;</span><span class="nc">undefined</span><span class="p">&gt;</span>&#39; &#39;;&#39;

code-exprs ::
      <span class="p">&lt;</span><span class="nc">EMPTY</span><span class="p">&gt;</span>
    | code-exprs code-expr

code-expr ::
      STRING
    | VARIABLE
    | optional
    | list

optional ::
      &#39;(&#39; CONDITIONAL &#39;?&#39; code-exprs &#39;)&#39;
    | &#39;(&#39; CONDITIONAL &#39;?&#39; code-exprs &#39;:&#39; code-exprs &#39;)&#39;

list ::
      &#39;[&#39; VARIABLE &#39;:&#39; code-exprs &#39;]&#39;
    | &#39;[&#39; VARIABLE &#39;{&#39; NUMBER &#39;}&#39; &#39;:&#39; code-exprs &#39;]&#39;
    | &#39;[&#39; VARIABLE &#39;{&#39; NUMBER &#39;,&#39; NUMBER &#39;}&#39; &#39;:&#39; code-exprs &#39;]&#39;
</pre></div>
</div>
<p>A code template is a sequence of string literals, variables, optional elements
and lists, or a reference to another code template, or a special value
<code class="docutils literal notranslate"><span class="pre">&lt;undefined&gt;</span></code>. Variables are placeholders that are substituted during code
generation phase. List variables are special: when expanding list templates,
re2rust repeats expressions the right hand side of the column a few times, each
time replacing occurrences of the list variable with a value specific to this
repetition. Lists have optional bounds (negative values are counted from the
end, e.g. <code class="docutils literal notranslate"><span class="pre">-1</span></code> means the last element). Conditional names start with a dot.
Both conditionals and variables may be either local (specific to the given
code template) or global (allowed in all code templates). When re2rust reads
syntax file, it checks that each code template uses only the variables and
conditionals that are allowed in it.</p>
<p>For example, the following code template defines if-then-else construct for a
C-like language:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="nl">code</span><span class="p">:</span><span class="n">if_then_else</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="n">branch</span><span class="p">{</span><span class="mi">0</span><span class="p">}</span><span class="o">:</span><span class="w"> </span><span class="n">topindent</span><span class="w"> </span><span class="s">&quot;if &quot;</span><span class="w"> </span><span class="n">cond</span><span class="w"> </span><span class="s">&quot; {&quot;</span><span class="w"> </span><span class="n">nl</span><span class="w"></span>
<span class="w">        </span><span class="n">indent</span><span class="w"> </span><span class="p">[</span><span class="nl">stmt</span><span class="p">:</span><span class="w"> </span><span class="n">stmt</span><span class="p">]</span><span class="w"> </span><span class="n">dedent</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="n">branch</span><span class="p">{</span><span class="mi">1</span><span class="o">:</span><span class="mi">-1</span><span class="p">}</span><span class="o">:</span><span class="w"> </span><span class="n">topindent</span><span class="w"> </span><span class="s">&quot;} else&quot;</span><span class="w"> </span><span class="p">(.</span><span class="n">cond</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot; if &quot;</span><span class="w"> </span><span class="n">cond</span><span class="p">)</span><span class="w"> </span><span class="s">&quot; {&quot;</span><span class="w"> </span><span class="n">nl</span><span class="w"></span>
<span class="w">        </span><span class="n">indent</span><span class="w"> </span><span class="p">[</span><span class="nl">stmt</span><span class="p">:</span><span class="w"> </span><span class="n">stmt</span><span class="p">]</span><span class="w"> </span><span class="n">dedent</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="n">topindent</span><span class="w"> </span><span class="s">&quot;}&quot;</span><span class="w"> </span><span class="n">nl</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">branch</span></code> is a list variable: <code class="docutils literal notranslate"><span class="pre">branch{0}</span></code> expands to the first branch
(which is special, as there is no <code class="docutils literal notranslate"><span class="pre">else</span></code> part), <code class="docutils literal notranslate"><span class="pre">branch{1:-1}</span></code> expands to
all remaining branches (if any). <code class="docutils literal notranslate"><span class="pre">stmt</span></code> is also a list variable:
<code class="docutils literal notranslate"><span class="pre">[stmt:</span> <span class="pre">stmt]</span></code> is a nested list that expands to a list of statements in the
body of the current branch. <code class="docutils literal notranslate"><span class="pre">topindent</span></code>, <code class="docutils literal notranslate"><span class="pre">indent</span></code>, <code class="docutils literal notranslate"><span class="pre">dedent</span></code> and <code class="docutils literal notranslate"><span class="pre">nl</span></code>
are global variables, and <code class="docutils literal notranslate"><span class="pre">.cond</span></code> is a local conditional (their meaning is
described below). This code template could produce the following code:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// do something</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// do something else</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// don&#39;t do anything</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Here’s a list of all code templates supported by re2rust with their local
variables and conditionals. Note that a particular definition may, but does
not have to use local variables and conditionals.
Any unused code templates should be set to <code class="docutils literal notranslate"><span class="pre">&lt;undefined&gt;</span></code>.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">code:var_local</span></code></dt><dd><p>Declaration or definition of a local variable. Supported variables:
<code class="docutils literal notranslate"><span class="pre">type</span></code> (the type of the variable), <code class="docutils literal notranslate"><span class="pre">name</span></code> (its name) and <code class="docutils literal notranslate"><span class="pre">init</span></code>
(initial value, if any). Conditionals: <code class="docutils literal notranslate"><span class="pre">.init</span></code> (true if there is an
initializer).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:var_global</span></code></dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">code:var_local</span></code>, except that it’s used in top-level.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:const_local</span></code></dt><dd><p>Definition of a local constant. Supported variables: <code class="docutils literal notranslate"><span class="pre">type</span></code> (the type
of the constant), <code class="docutils literal notranslate"><span class="pre">name</span></code> (its name) and <code class="docutils literal notranslate"><span class="pre">init</span></code> (initial value).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:const_global</span></code></dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">code:const_local</span></code>, except that it’s used in top-level.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:array_local</span></code></dt><dd><p>Definition of a local array (table). Supported variables: <code class="docutils literal notranslate"><span class="pre">type</span></code> (the
type of array elements), <code class="docutils literal notranslate"><span class="pre">name</span></code> (array name), <code class="docutils literal notranslate"><span class="pre">size</span></code> (its size),
<code class="docutils literal notranslate"><span class="pre">row</span></code> (a list variable that does not itself produce any code, but
expands list expression as many times as there are rows in the table)
and <code class="docutils literal notranslate"><span class="pre">elem</span></code> (a list variable that expands to all table elements in the
current row – it’s meant to be nested in the <code class="docutils literal notranslate"><span class="pre">row</span></code> list).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:array_global</span></code></dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">code:array_local</span></code>, except that it’s used in top-level.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:array_elem</span></code></dt><dd><p>Reference to an element of an array (table). Supported variables:
<code class="docutils literal notranslate"><span class="pre">array</span></code> (the name of the array) and <code class="docutils literal notranslate"><span class="pre">index</span></code> (index of the element).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:enum</span></code></dt><dd><p>Definition of an enumeration (it may be defined using a special language
construct for enumerations, or simply as a few standalone constants).
Supported variables are <code class="docutils literal notranslate"><span class="pre">type</span></code> (user-defined enumeration type or type
of the constants), <code class="docutils literal notranslate"><span class="pre">elem</span></code> (list variable that expands to the name of
each member) and <code class="docutils literal notranslate"><span class="pre">init</span></code> (initializer for each member). Conditionals:
<code class="docutils literal notranslate"><span class="pre">.init</span></code> (true if there is an initializer).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:enum_elem</span></code></dt><dd><p>Enumeration element (a member of a user-defined enumeration type or a
name of a constant, depending on how <code class="docutils literal notranslate"><span class="pre">code:enum</span></code> is defined).
Supported variables are <code class="docutils literal notranslate"><span class="pre">name</span></code> (the name of the element) and <code class="docutils literal notranslate"><span class="pre">type</span></code>
(its type).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:assign</span></code></dt><dd><p>Assignment statement. Supported variables are <code class="docutils literal notranslate"><span class="pre">lhs</span></code> (left hand side)
and <code class="docutils literal notranslate"><span class="pre">rhs</span></code> (right hand side).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:type_int</span></code></dt><dd><p>Signed integer type.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:type_uint</span></code></dt><dd><p>Unsigned integer type.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:type_yybm</span></code></dt><dd><p>Type of elements in the <code class="docutils literal notranslate"><span class="pre">yybm</span></code> table.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:type_yytarget</span></code></dt><dd><p>Type of elements in the <code class="docutils literal notranslate"><span class="pre">yytarget</span></code> table.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:cmp_eq</span></code></dt><dd><p>Operator “equals”.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:cmp_ne</span></code></dt><dd><p>Operator “not equals”.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:cmp_lt</span></code></dt><dd><p>Operator “less than”.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:cmp_gt</span></code></dt><dd><p>Operator “greater than”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:cmp_le</span></code></dt><dd><p>Operator “less or equal”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:cmp_ge</span></code></dt><dd><p>Operator “greater or equal”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:if_then_else</span></code></dt><dd><p>If-then-else statement with one or more branches. Supported variables:
<code class="docutils literal notranslate"><span class="pre">branch</span></code> (a list variable that does not itself produce any code, but
expands list expression as many times as there are branches), <code class="docutils literal notranslate"><span class="pre">cond</span></code>
(condition of the current branch) and <code class="docutils literal notranslate"><span class="pre">stmt</span></code> (a list variable that
expands to all statements in the current branch). Conditionals:
<code class="docutils literal notranslate"><span class="pre">.cond</span></code> (true if the current branch has a condition), <code class="docutils literal notranslate"><span class="pre">.many</span></code> (true
if there’s more than one branch).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:if_then_else_oneline</span></code></dt><dd><p>A specialization of <code class="docutils literal notranslate"><span class="pre">code:if_then_else</span></code> for the case when all branches
have one-line statements. If this is <code class="docutils literal notranslate"><span class="pre">&lt;undefined&gt;</span></code>,
<code class="docutils literal notranslate"><span class="pre">code:if_then_else</span></code> is used instead.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:switch</span></code></dt><dd><p>A switch statement with one or more cases. Supported variables: <code class="docutils literal notranslate"><span class="pre">expr</span></code>
(the switched-on expression) and <code class="docutils literal notranslate"><span class="pre">case</span></code> (a list variable that expands
to all cases-groups with their code blocks).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:switch_cases</span></code></dt><dd><p>A group of switch cases that maps to a single code block. Supported
variables are <code class="docutils literal notranslate"><span class="pre">case</span></code> (a list variable that expands to all cases in
this group) and <code class="docutils literal notranslate"><span class="pre">stmt</span></code> (a list variable that expands to all statements
in the code block.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:switch_cases_oneline</span></code></dt><dd><p>A specialization of <code class="docutils literal notranslate"><span class="pre">code:switch_cases</span></code> for the case when the code
block consists of a single one-line statement. If this is
<code class="docutils literal notranslate"><span class="pre">&lt;undefined&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">code:switch_cases</span></code> is used instead.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:switch_case_range</span></code></dt><dd><p>A single switch case that covers a range of values (possibly consisting
of a single value). Supported variable: <code class="docutils literal notranslate"><span class="pre">val</span></code> (a list variable that
expands to all values in the range). Supported conditionals: <code class="docutils literal notranslate"><span class="pre">.many</span></code>
(true if there’s more than one value in the range) and
<code class="docutils literal notranslate"><span class="pre">.char_literals</span></code> (true if this is a switch on character literals –
some languages provide special syntax for this case).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:switch_case_default</span></code></dt><dd><p>Default switch case.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:loop</span></code></dt><dd><p>A loop that runs forever (unless interrupted from the loop body).
Supported variables: <code class="docutils literal notranslate"><span class="pre">label</span></code> (loop label), <code class="docutils literal notranslate"><span class="pre">stmt</span></code> (a list variable
that expands to all statements in the loop body).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:continue</span></code></dt><dd><p>Continue statement. Supported variables: <code class="docutils literal notranslate"><span class="pre">label</span></code> (label from which to
continue execution).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:goto</span></code></dt><dd><p>Goto statement. Supported variables: <code class="docutils literal notranslate"><span class="pre">label</span></code> (label of the jump
target).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:fndecl</span></code></dt><dd><p>Function declaration. Supported variables: <code class="docutils literal notranslate"><span class="pre">name</span></code> (function name),
<code class="docutils literal notranslate"><span class="pre">type</span></code> (return type), <code class="docutils literal notranslate"><span class="pre">arg</span></code> (a list variable that does not itself
produce code, but expands list expression as many times as there are
function arguments), <code class="docutils literal notranslate"><span class="pre">argname</span></code> (name of the current argument),
<code class="docutils literal notranslate"><span class="pre">argtype</span></code> (type of the current argument). Conditional: <code class="docutils literal notranslate"><span class="pre">.type</span></code> (true
if this is a non-void function).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:fndef</span></code></dt><dd><p>Like <code class="docutils literal notranslate"><span class="pre">code:fndecl</span></code>, but used for function definitions, so it has one
additional list variable <code class="docutils literal notranslate"><span class="pre">stmt</span></code> that expands to all statements in the
function body.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:fncall</span></code></dt><dd><p>Function call statement. Supported variables: <code class="docutils literal notranslate"><span class="pre">name</span></code> (function name),
<code class="docutils literal notranslate"><span class="pre">retval</span></code> (l-value where the return value is stored, if any) and
<code class="docutils literal notranslate"><span class="pre">arg</span></code> (a list variable that expands to all function arguments).
Conditionals: <code class="docutils literal notranslate"><span class="pre">.args</span></code> (true if the function has arguments) and
<code class="docutils literal notranslate"><span class="pre">.retval</span></code> (true if return value needs to be saved).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:tailcall</span></code></dt><dd><p>Tail call statement. Supported variables: <code class="docutils literal notranslate"><span class="pre">name</span></code> (function name),
and <code class="docutils literal notranslate"><span class="pre">arg</span></code> (a list variable that expands to all function arguments).
Conditionals: <code class="docutils literal notranslate"><span class="pre">.args</span></code> (true if the function has arguments) and
<code class="docutils literal notranslate"><span class="pre">.retval</span></code> (true if this is a non-void function).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:recursive_functions</span></code></dt><dd><p>Program body with <code class="docutils literal notranslate"><span class="pre">--recursive-functions</span></code> code model. Supported
variables: <code class="docutils literal notranslate"><span class="pre">fn</span></code> (a list variable that does not itself produce any
code, but expands list expression as many times as there are functions),
<code class="docutils literal notranslate"><span class="pre">fndecl</span></code> (declaration of the current function) and <code class="docutils literal notranslate"><span class="pre">fndef</span></code>
(definition of the current function).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:fingerprint</span></code></dt><dd><p>The fingerprint at the top of the generated output file. Supported
variables: <code class="docutils literal notranslate"><span class="pre">ver</span></code> (re2rust version that was used to generate this) and
<code class="docutils literal notranslate"><span class="pre">date</span></code> (generation date).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:line_info</span></code></dt><dd><p>The format of line directives (if this is set to <code class="docutils literal notranslate"><span class="pre">&lt;undefined&gt;</span></code>, no
directives are generated). Supported variables: <code class="docutils literal notranslate"><span class="pre">line</span></code> (line number)
and <code class="docutils literal notranslate"><span class="pre">file</span></code> (filename).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:abort</span></code></dt><dd><p>A statement that aborts program execution.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:yydebug</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">YYDEBUG</span></code> statement, possibly specialized for different APIs.
Supported variables: <code class="docutils literal notranslate"><span class="pre">YYDEBUG</span></code>, <code class="docutils literal notranslate"><span class="pre">yyrecord</span></code>, <code class="docutils literal notranslate"><span class="pre">yych</span></code> (map to the
corresponding <code class="docutils literal notranslate"><span class="pre">re2c:</span></code> configurations), <code class="docutils literal notranslate"><span class="pre">state</span></code> (DFA state number).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:yypeek</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">YYPEEK</span></code> statement, possibly specialized for different APIs.
Supported variables: <code class="docutils literal notranslate"><span class="pre">YYPEEK</span></code>, <code class="docutils literal notranslate"><span class="pre">YYCTYPE</span></code>, <code class="docutils literal notranslate"><span class="pre">YYINPUT</span></code>, <code class="docutils literal notranslate"><span class="pre">YYCURSOR</span></code>,
<code class="docutils literal notranslate"><span class="pre">yyrecord</span></code>, <code class="docutils literal notranslate"><span class="pre">yych</span></code> (map to the corresponding <code class="docutils literal notranslate"><span class="pre">re2c:</span></code>
configurations). Conditionals: <code class="docutils literal notranslate"><span class="pre">.cast</span></code> (true if
<code class="docutils literal notranslate"><span class="pre">re2c:yych:conversion</span></code> is set to non-zero).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:yyskip</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">YYSKIP</span></code> statement, possibly specialized for different APIs.
Supported variables: <code class="docutils literal notranslate"><span class="pre">YYSKIP</span></code>, <code class="docutils literal notranslate"><span class="pre">YYCURSOR</span></code>, <code class="docutils literal notranslate"><span class="pre">yyrecord</span></code> (map to the
corresponding <code class="docutils literal notranslate"><span class="pre">re2c:</span></code> configurations).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:yybackup</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">YYBACKUP</span></code> statement, possibly specialized for different APIs.
Supported variables: <code class="docutils literal notranslate"><span class="pre">YYBACKUP</span></code>, <code class="docutils literal notranslate"><span class="pre">YYCURSOR</span></code>, <code class="docutils literal notranslate"><span class="pre">YYMARKER</span></code>,
<code class="docutils literal notranslate"><span class="pre">yyrecord</span></code> (map to the corresponding <code class="docutils literal notranslate"><span class="pre">re2c:</span></code> configurations).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:yybackupctx</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">YYBACKUPCTX</span></code> statement, possibly specialized for different APIs.
Supported variables: <code class="docutils literal notranslate"><span class="pre">YYBACKUPCTX</span></code>, <code class="docutils literal notranslate"><span class="pre">YYCURSOR</span></code>, <code class="docutils literal notranslate"><span class="pre">YYCTXMARKER</span></code>,
<code class="docutils literal notranslate"><span class="pre">yyrecord</span></code> (map to the corresponding <code class="docutils literal notranslate"><span class="pre">re2c:</span></code> configurations).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:yyskip_yypeek</span></code></dt><dd><p>Combined <code class="docutils literal notranslate"><span class="pre">code:yyskip</span></code> and <code class="docutils literal notranslate"><span class="pre">code:yypeek</span></code> statement (defaults to
<code class="docutils literal notranslate"><span class="pre">code:yyskip</span></code> followed by <code class="docutils literal notranslate"><span class="pre">code:yypeek</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:yypeek_yyskip</span></code></dt><dd><p>Combined <code class="docutils literal notranslate"><span class="pre">code:yypeek</span></code> and <code class="docutils literal notranslate"><span class="pre">code:yyskip</span></code> statement (defaults to
<code class="docutils literal notranslate"><span class="pre">code:yypeek</span></code> followed by <code class="docutils literal notranslate"><span class="pre">code:yyskip</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:yyskip_yybackup</span></code></dt><dd><p>Combined <code class="docutils literal notranslate"><span class="pre">code:yyskip</span></code> and <code class="docutils literal notranslate"><span class="pre">code:yybackup</span></code> statement (defaults to
<code class="docutils literal notranslate"><span class="pre">code:yyskip</span></code> followed by <code class="docutils literal notranslate"><span class="pre">code:yybackup</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:yybackup_yyskip</span></code></dt><dd><p>Combined <code class="docutils literal notranslate"><span class="pre">code:yybackup</span></code> and <code class="docutils literal notranslate"><span class="pre">code:yyskip</span></code> statement (defaults to
<code class="docutils literal notranslate"><span class="pre">code:yybackup</span></code> followed by <code class="docutils literal notranslate"><span class="pre">code:yyskip</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:yybackup_yypeek</span></code></dt><dd><p>Combined <code class="docutils literal notranslate"><span class="pre">code:yybackup</span></code> and <code class="docutils literal notranslate"><span class="pre">code:yypeek</span></code> statement (defaults to
<code class="docutils literal notranslate"><span class="pre">code:yybackup</span></code> followed by <code class="docutils literal notranslate"><span class="pre">code:yypeek</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:yyskip_yybackup_yypeek</span></code></dt><dd><p>Combined <code class="docutils literal notranslate"><span class="pre">code:yyskip</span></code>, <code class="docutils literal notranslate"><span class="pre">code:yybackup</span></code> and <code class="docutils literal notranslate"><span class="pre">code:yypeek</span></code>
statement (defaults to``code:yyskip`` followed by <code class="docutils literal notranslate"><span class="pre">code:yybackup</span></code>
followed by <code class="docutils literal notranslate"><span class="pre">code:yypeek</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:yybackup_yypeek_yyskip</span></code></dt><dd><p>Combined <code class="docutils literal notranslate"><span class="pre">code:yybackup</span></code>, <code class="docutils literal notranslate"><span class="pre">code:yypeek</span></code> and <code class="docutils literal notranslate"><span class="pre">code:yyskip</span></code>
statement (defaults to``code:yybackup`` followed by <code class="docutils literal notranslate"><span class="pre">code:yypeek</span></code>
followed by <code class="docutils literal notranslate"><span class="pre">code:yyskip</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:yyrestore</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">YYRESTORE</span></code> statement, possibly specialized for different APIs.
Supported variables: <code class="docutils literal notranslate"><span class="pre">YYRESTORE</span></code>, <code class="docutils literal notranslate"><span class="pre">YYCURSOR</span></code>, <code class="docutils literal notranslate"><span class="pre">YYMARKER</span></code>,
<code class="docutils literal notranslate"><span class="pre">yyrecord</span></code> (map to the corresponding <code class="docutils literal notranslate"><span class="pre">re2c:</span></code> configurations).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:yyrestorectx</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">YYRESTORECTX</span></code> statement, possibly specialized for different APIs.
Supported variables: <code class="docutils literal notranslate"><span class="pre">YYRESTORECTX</span></code>, <code class="docutils literal notranslate"><span class="pre">YYCURSOR</span></code>, <code class="docutils literal notranslate"><span class="pre">YYCTXMARKER</span></code>,
<code class="docutils literal notranslate"><span class="pre">yyrecord</span></code> (map to the corresponding <code class="docutils literal notranslate"><span class="pre">re2c:</span></code> configurations).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:yyrestoretag</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">YYRESTORETAG</span></code> statement, possibly specialized for different APIs.
Supported variables: <code class="docutils literal notranslate"><span class="pre">YYRESTORETAG</span></code>, <code class="docutils literal notranslate"><span class="pre">YYCURSOR</span></code>, <code class="docutils literal notranslate"><span class="pre">yyrecord</span></code> (map
to the corresponding <code class="docutils literal notranslate"><span class="pre">re2c:</span></code> configurations), <code class="docutils literal notranslate"><span class="pre">tag</span></code> (the name of tag
variable used to restore position).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:yyshift</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">YYSHIFT</span></code> statement, possibly specialized for different APIs.
Supported variables: <code class="docutils literal notranslate"><span class="pre">YYSHIFT</span></code>, <code class="docutils literal notranslate"><span class="pre">YYCURSOR</span></code>, <code class="docutils literal notranslate"><span class="pre">yyrecord</span></code> (map to the
corresponding <code class="docutils literal notranslate"><span class="pre">re2c:</span></code> configurations), <code class="docutils literal notranslate"><span class="pre">offset</span></code> (the number of code
units to shift the current position).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:yyshiftstag</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">YYSHIFTSTAG</span></code> statement, possibly specialized for different APIs.
Supported variables: <code class="docutils literal notranslate"><span class="pre">YYSHIFTSTAG</span></code>, <code class="docutils literal notranslate"><span class="pre">yyrecord</span></code>, <code class="docutils literal notranslate"><span class="pre">negative</span></code> (map
to the corresponding <code class="docutils literal notranslate"><span class="pre">re2c:</span></code> configurations), <code class="docutils literal notranslate"><span class="pre">tag</span></code> (tag variable
which needs to be shifted), <code class="docutils literal notranslate"><span class="pre">offset</span></code> (the number of code units to
shift). Conditionals: <code class="docutils literal notranslate"><span class="pre">.nested</span></code> (true if this is a nested tag – in
this case its value may equal to <code class="docutils literal notranslate"><span class="pre">re2c:tags:negative</span></code>, which should
not be shifted).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:yyshiftmtag</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">YYSHIFTMTAG</span></code> statement, possibly specialized for different APIs.
Supported variables: <code class="docutils literal notranslate"><span class="pre">YYSHIFTMTAG</span></code> (maps to the corresponding
<code class="docutils literal notranslate"><span class="pre">re2c:</span></code> configuration), <code class="docutils literal notranslate"><span class="pre">tag</span></code> (tag variable which needs to be
shifted), <code class="docutils literal notranslate"><span class="pre">offset</span></code> (the number of code units to shift).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:yystagp</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">YYSTAGP</span></code> statement, possibly specialized for different APIs.
Supported variables: <code class="docutils literal notranslate"><span class="pre">YYSTAGP</span></code>, <code class="docutils literal notranslate"><span class="pre">YYCURSOR</span></code>, <code class="docutils literal notranslate"><span class="pre">yyrecord</span></code> (map to the
corresponding <code class="docutils literal notranslate"><span class="pre">re2c:</span></code> configurations), <code class="docutils literal notranslate"><span class="pre">tag</span></code> (tag variable that
should be updated).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:yymtagp</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">YYMTAGP</span></code> statement, possibly specialized for different APIs.
Supported variables: <code class="docutils literal notranslate"><span class="pre">YYMTAGP</span></code> (maps to the corresponding <code class="docutils literal notranslate"><span class="pre">re2c:</span></code>
configuration), <code class="docutils literal notranslate"><span class="pre">tag</span></code> (tag variable that should be updated).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:yystagn</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">YYSTAGN</span></code> statement, possibly specialized for different APIs.
Supported variables: <code class="docutils literal notranslate"><span class="pre">YYSTAGN</span></code>, <code class="docutils literal notranslate"><span class="pre">negative</span></code>, <code class="docutils literal notranslate"><span class="pre">yyrecord</span></code> (map to the
corresponding <code class="docutils literal notranslate"><span class="pre">re2c:</span></code> configurations), <code class="docutils literal notranslate"><span class="pre">tag</span></code> (tag variable that
should be updated).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:yymtagn</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">YYMTAGN</span></code> statement, possibly specialized for different APIs.
Supported variables: <code class="docutils literal notranslate"><span class="pre">YYMTAGN</span></code> (maps to the corresponding <code class="docutils literal notranslate"><span class="pre">re2c:</span></code>
configuration), <code class="docutils literal notranslate"><span class="pre">tag</span></code> (tag variable that should be updated).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:yycopystag</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">YYCOPYSTAG</span></code> statement, possibly specialized for different APIs.
Supported variables: <code class="docutils literal notranslate"><span class="pre">YYCOPYSTAG</span></code>, <code class="docutils literal notranslate"><span class="pre">yyrecord</span></code> (map to the
corresponding <code class="docutils literal notranslate"><span class="pre">re2c:</span></code> configurations), <code class="docutils literal notranslate"><span class="pre">lhs</span></code>, <code class="docutils literal notranslate"><span class="pre">rhs</span></code> (left and
right hand side tag variables of the copy operation).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:yycopymtag</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">YYCOPYMTAG</span></code> statement, possibly specialized for different APIs.
Supported variables: <code class="docutils literal notranslate"><span class="pre">YYCOPYMTAG</span></code>, <code class="docutils literal notranslate"><span class="pre">yyrecord</span></code> (map to the
corresponding <code class="docutils literal notranslate"><span class="pre">re2c:</span></code> configurations), <code class="docutils literal notranslate"><span class="pre">lhs</span></code>, <code class="docutils literal notranslate"><span class="pre">rhs</span></code> (left and
right hand side tag variables of the copy operation).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:yygetaccept</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">YYGETACCEPT</span></code> statement, possibly specialized for different APIs.
Supported variables: <code class="docutils literal notranslate"><span class="pre">YYGETACCEPT</span></code>, <code class="docutils literal notranslate"><span class="pre">yyrecord</span></code> (map to the
corresponding <code class="docutils literal notranslate"><span class="pre">re2c:</span></code> configurations), <code class="docutils literal notranslate"><span class="pre">var</span></code> (maps to
<code class="docutils literal notranslate"><span class="pre">re2c:yyaccept</span></code> configuration).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:yysetaccept</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">YYSETACCEPT</span></code> statement, possibly specialized for different APIs.
Supported variables: <code class="docutils literal notranslate"><span class="pre">YYSETACCEPT</span></code>, <code class="docutils literal notranslate"><span class="pre">yyrecord</span></code> (map to the
corresponding <code class="docutils literal notranslate"><span class="pre">re2c:</span></code> configurations), <code class="docutils literal notranslate"><span class="pre">var</span></code> (maps to
<code class="docutils literal notranslate"><span class="pre">re2c:yyaccept</span></code> configuration) and <code class="docutils literal notranslate"><span class="pre">val</span></code> (numeric value of the
accepted rule).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:yygetcond</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">YYGETCOND</span></code> statement, possibly specialized for different APIs.
Supported variables: <code class="docutils literal notranslate"><span class="pre">YYGETCOND</span></code>, <code class="docutils literal notranslate"><span class="pre">yyrecord</span></code> (map to the
corresponding <code class="docutils literal notranslate"><span class="pre">re2c:</span></code> configurations), <code class="docutils literal notranslate"><span class="pre">var</span></code> (maps to
<code class="docutils literal notranslate"><span class="pre">re2c:yycond</span></code> configuration).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:yysetcond</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">YYSETCOND</span></code> statement, possibly specialized for different APIs.
Supported variables: <code class="docutils literal notranslate"><span class="pre">YYSETCOND</span></code>, <code class="docutils literal notranslate"><span class="pre">yyrecord</span></code> (map to the
corresponding <code class="docutils literal notranslate"><span class="pre">re2c:</span></code> configurations), <code class="docutils literal notranslate"><span class="pre">var</span></code> (maps to
<code class="docutils literal notranslate"><span class="pre">re2c:yycond</span></code> configuration) and <code class="docutils literal notranslate"><span class="pre">val</span></code> (numeric condition
identifier).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:yygetstate</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">YYGETSTATE</span></code> statement, possibly specialized for different APIs.
Supported variables: <code class="docutils literal notranslate"><span class="pre">YYGETSTATE</span></code>, <code class="docutils literal notranslate"><span class="pre">yyrecord</span></code> (map to the
corresponding <code class="docutils literal notranslate"><span class="pre">re2c:</span></code> configurations), <code class="docutils literal notranslate"><span class="pre">var</span></code> (maps to
<code class="docutils literal notranslate"><span class="pre">re2c:yystate</span></code> configuration).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:yysetstate</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">YYSETSTATE</span></code> statement, possibly specialized for different APIs.
Supported variables: <code class="docutils literal notranslate"><span class="pre">YYSETSTATE</span></code>, <code class="docutils literal notranslate"><span class="pre">yyrecord</span></code> (map to the
corresponding <code class="docutils literal notranslate"><span class="pre">re2c:</span></code> configurations), <code class="docutils literal notranslate"><span class="pre">var</span></code> (maps to
<code class="docutils literal notranslate"><span class="pre">re2c:yystate</span></code> configuration) and <code class="docutils literal notranslate"><span class="pre">val</span></code> (state number).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:yylessthan</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">YYLESSTHAN</span></code> statement, possibly specialized for different APIs.
Supported variables: <code class="docutils literal notranslate"><span class="pre">YYLESSTHAN</span></code>, <code class="docutils literal notranslate"><span class="pre">YYCURSOR</span></code>, <code class="docutils literal notranslate"><span class="pre">YYLIMIT</span></code>,
<code class="docutils literal notranslate"><span class="pre">yyrecord</span></code> (map to the corresponding <code class="docutils literal notranslate"><span class="pre">re2c:</span></code> configurations),
<code class="docutils literal notranslate"><span class="pre">need</span></code> (the number of code units to check against). Conditional:
<code class="docutils literal notranslate"><span class="pre">.many</span></code> (true if the <code class="docutils literal notranslate"><span class="pre">need</span></code> is more than one).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:yybm_filter</span></code></dt><dd><p>Condition that is used to filter out <code class="docutils literal notranslate"><span class="pre">yych</span></code> values that are not
covered by the <code class="docutils literal notranslate"><span class="pre">yybm</span></code> table (used with <code class="docutils literal notranslate"><span class="pre">--bitmaps</span></code> option).
Supported variable: <code class="docutils literal notranslate"><span class="pre">yych</span></code> (maps to <code class="docutils literal notranslate"><span class="pre">re2c:yych</span></code> configuration).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code:yybm_match</span></code></dt><dd><p>The format of <code class="docutils literal notranslate"><span class="pre">yybm</span></code> table check (generated with <code class="docutils literal notranslate"><span class="pre">--bitmaps</span></code>
option). Supported variables: <code class="docutils literal notranslate"><span class="pre">yybm</span></code>, <code class="docutils literal notranslate"><span class="pre">yych</span></code> (map to the
corresponding <code class="docutils literal notranslate"><span class="pre">re2c:</span></code> configurations), <code class="docutils literal notranslate"><span class="pre">offset</span></code> (offset in the
<code class="docutils literal notranslate"><span class="pre">yybm</span></code> table that needs to be added to <code class="docutils literal notranslate"><span class="pre">yych</span></code>) and <code class="docutils literal notranslate"><span class="pre">mask</span></code> (bit
mask that should be applied to the table entry to retrieve the boolean
value that needs to be checked)</p>
</dd>
</dl>
<p>Here’s a list of all global variables that are allowed in syntax files:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">nl</span></code></dt><dd><p>A newline.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">indent</span></code></dt><dd><p>A variable that does not produce any code, but has a side-effect of
increasing indentation level.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dedent</span></code></dt><dd><p>A variable that does not produce any code, but has a side-effect of
decreasing indentation level.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">topindent</span></code></dt><dd><p>Indentation string for the current statement. Indentation level is
tracked and automatically updated by the code generator.</p>
</dd>
</dl>
<p>Here’s a list of all global conditionals that are allowed in syntax files:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">.api.simple</span></code></dt><dd><p>True if simple API is used (<code class="docutils literal notranslate"><span class="pre">--api</span> <span class="pre">simple</span></code> or <code class="docutils literal notranslate"><span class="pre">re2c:api</span> <span class="pre">=</span> <span class="pre">simple</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">.api.generic</span></code></dt><dd><p>True if generic API is used (<code class="docutils literal notranslate"><span class="pre">--api</span> <span class="pre">generic</span></code> or
<code class="docutils literal notranslate"><span class="pre">re2c:api</span> <span class="pre">=</span> <span class="pre">generic</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">.api.record</span></code></dt><dd><p>True if record API is used (<code class="docutils literal notranslate"><span class="pre">--api</span> <span class="pre">record</span></code> or <code class="docutils literal notranslate"><span class="pre">re2c:api</span> <span class="pre">=</span> <span class="pre">record</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">.api_style.functions</span></code></dt><dd><p>True if function-like API style is used
(<code class="docutils literal notranslate"><span class="pre">re2c:api-style</span> <span class="pre">=</span> <span class="pre">functions</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">.api_style.freeform</span></code></dt><dd><p>True if free-form API style is used (<code class="docutils literal notranslate"><span class="pre">re2c:api-style</span> <span class="pre">=</span> <span class="pre">free-form</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">.case_ranges</span></code></dt><dd><p>True if case ranges feature is enabled (<code class="docutils literal notranslate"><span class="pre">--case-ranges</span></code> or
<code class="docutils literal notranslate"><span class="pre">re2c:case-ranges</span> <span class="pre">=</span> <span class="pre">1</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">.code_model.goto_label</span></code></dt><dd><p>True if  code model based on goto/label is used (<code class="docutils literal notranslate"><span class="pre">--goto-label</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">.code_model.loop_switch</span></code></dt><dd><p>True if code model based on loop/switch is used (<code class="docutils literal notranslate"><span class="pre">--loop-switch</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">.code_model.recursive_functions</span></code></dt><dd><p>True if code model based on recursive functions is used
(<code class="docutils literal notranslate"><span class="pre">--recursive-function</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">.date</span></code></dt><dd><p>True if the generated fingerprint should contain generation date.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">.loop_label</span></code></dt><dd><p>True if re2rust generated loops must have a label (<code class="docutils literal notranslate"><span class="pre">re2c:label:yyloop</span></code>
is set to a nonempty string).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">.monadic</span></code></dt><dd><p>True if the generated code should be monadic (<code class="docutils literal notranslate"><span class="pre">re2c:monadic</span> <span class="pre">=</span> <span class="pre">1</span></code>).
This is only relevant for pure functional languages.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">.start_conditions</span></code></dt><dd><p>True if start conditions are enabled (<code class="docutils literal notranslate"><span class="pre">--start-conditions</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">.storable_state</span></code></dt><dd><p>True if storable state is enabled (<code class="docutils literal notranslate"><span class="pre">--storable-state</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">.unsafe</span></code></dt><dd><p>True if re2rust should use “unsafe” blocks in order to generate faster
code (<code class="docutils literal notranslate"><span class="pre">--unsafe</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:unsafe</span> <span class="pre">=</span> <span class="pre">1</span></code>). This is only relevant for
languages that have “unsafe” feature.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">.version</span></code></dt><dd><p>True if the generated fingerprint should contain re2rust version.</p>
</dd>
</dl>
</div></blockquote>
</section>
</section>
<section id="handling-the-end-of-input">
<h2>Handling the end of input<a class="headerlink" href="#handling-the-end-of-input" title="Permalink to this headline">¶</a></h2>
<p>One of the main problems for the lexer is to know when to stop.
There are a few terminating conditions:</p>
<ul class="simple">
<li><p>the lexer may match some rule (including default rule <code class="docutils literal notranslate"><span class="pre">*</span></code>) and come to a
final state</p></li>
<li><p>the lexer may fail to match any rule and come to a default state</p></li>
<li><p>the lexer may reach the end of input</p></li>
</ul>
<p>The first two conditions terminate the lexer in a “natural” way: it comes to a
state with no outgoing transitions, and the matching automatically stops. The
third condition, end of input, is different: it may happen in any state, and the
lexer should be able to handle it. Checking for the end of input interrupts the
normal lexer workflow and adds conditional branches to the generated program,
therefore it is necessary to minimize the number of such checks. re2rust supports
a few different methods for handling the end of input. Which one to use depends
on the complexity of regular expressions, the need for buffering, performance
considerations and other factors. Here is a list of methods:</p>
<ul>
<li><p><strong>Sentinel.</strong>
This method eliminates the need for the end of input checks altogether. It is
simple and efficient, but limited to the case when there is a natural
“sentinel” character that can never occur in valid input. This character may
still occur in invalid input, but it should not be allowed by the regular
expressions, except perhaps as the last character of a rule. The sentinel is
appended at the end of input and serves as a stop signal: when the lexer reads
this character, it is either a syntax error or the end of input. In both
cases the lexer should stop. This method is used if <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> is disabled
with <code class="docutils literal notranslate"><span class="pre">re2c:yyfill:enable</span> <span class="pre">=</span> <span class="pre">0;</span></code> and <code class="docutils literal notranslate"><span class="pre">re2c:eof</span></code> has the default value
<code class="docutils literal notranslate"><span class="pre">-1</span></code>.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
</li>
<li><p><strong>Sentinel with bounds checks.</strong>
This method is generic: it allows one to handle any input without restrictions on
the regular expressions. The idea is to reduce the number of end of input
checks by performing them only on certain characters. Similar to the
“sentinel” method, one of the characters is chosen as a “sentinel” and
appended at the end of input. However, there is no restriction on where the
sentinel may occur (in fact, any character can be chosen for a sentinel).
When the lexer reads this character, it additionally performs a bounds check.
If the current position is within bounds, the lexer resumes matching and
handles the sentinel as a regular character. Otherwise it invokes <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code>
(unless it is disabled). If more input is supplied, the lexer will rematch the
last character and continue as if the sentinel wasn’t there. Otherwise it must
be the real end of input, and the lexer stops. This method is used when
<code class="docutils literal notranslate"><span class="pre">re2c:eof</span></code> has non-negative value (it should be set to the numeric value of
the sentinel). <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> is optional.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
</li>
<li><p><strong>Bounds checks with padding.</strong>
This method is generic, and it may be faster than the “sentinel with bounds
checks” method, but it is also more complex. The idea is to partition DFA
states into strongly connected components (SCCs) and generate a single check
per SCC for enough characters to cover the longest non-looping path in this
SCC. This reduces the number of checks, but there is a problem with short
lexemes at the end of input, as the check requires enough characters to cover
the longest lexeme. This can be fixed by padding the input with a few fake
characters that do not form a valid lexeme suffix (so that the lexer cannot
match them). The length of padding should be <code class="docutils literal notranslate"><span class="pre">YYMAXFILL</span></code>, generated with
a <code class="docutils literal notranslate"><span class="pre">max</span></code> block. If there is not enough input, the lexer invokes <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code>
which should supply at least the required number of characters or not return.
This method is used if <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> is enabled and <code class="docutils literal notranslate"><span class="pre">re2c:eof</span></code> is <code class="docutils literal notranslate"><span class="pre">-1</span></code>
(this is the default configuration).</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
</li>
<li><p><strong>Custom checks.</strong>
Generic API allows one to override basic operations like reading a character,
which makes it possible to include the end-of-input checks as part of them.
This approach is error-prone and should be used with caution. To use a custom
method, enable generic API with <code class="docutils literal notranslate"><span class="pre">--api</span> <span class="pre">custom</span></code> or <code class="docutils literal notranslate"><span class="pre">re2c:api</span> <span class="pre">=</span> <span class="pre">custom;</span></code> and
disable default bounds checks with <code class="docutils literal notranslate"><span class="pre">re2c:yyfill:enable</span> <span class="pre">=</span> <span class="pre">0;</span></code> or
<code class="docutils literal notranslate"><span class="pre">re2c:yyfill:check</span> <span class="pre">=</span> <span class="pre">0;</span></code>.</p></li>
</ul>
<p>The following subsections contain an example of each method.</p>
<section id="sentinel">
<h3>Sentinel<a class="headerlink" href="#sentinel" title="Permalink to this headline">¶</a></h3>
<p>This example uses a sentinel character to handle the end of input. The program
counts space-separated words in a null-terminated string. The sentinel is null:
it is the last character of each input string, and it is not allowed in the
middle of a lexeme by any of the rules (in particular, it is not included in
character ranges where it is easy to overlook). If a null occurs in the middle
of a string, it is a syntax error and the lexer will match default rule <code class="docutils literal notranslate"><span class="pre">*</span></code>,
but it won’t read past the end of input or crash (use
<a class="reference external" href="https://re2c.org/manual/basics/warnings/warnings.html#wsentinel-in-midrule">-Wsentinel-in-midrule</a>
warning and <code class="docutils literal notranslate"><span class="pre">re2c:sentinel</span></code> configuration to verify this). Configuration
<code class="docutils literal notranslate"><span class="pre">re2c:yyfill:enable</span> <span class="pre">=</span> <span class="pre">0;</span></code> suppresses the generation of bounds checks and
<code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> invocations.</p>
<p><a class="reference external" href="../../playground?example=rust/eof/01_sentinel.re"><img alt="run_eof_01" class="feed" src="../_images/play.png" style="width: 2em;" /></a>   <a class="reference external" href="../../playground?example=rust/eof/01_sentinel.re">Run in playground</a></p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2rust $INPUT -o $OUTPUT --api simple</span>

<span class="k">fn</span> <span class="nf">lex</span><span class="p">(</span><span class="n">yyinput</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="kt">isize</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// The input must be null-terminated, otherwise the function has UB.</span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">yyinput</span><span class="p">.</span><span class="n">last</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">0</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">yycursor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="o">&#39;</span><span class="na">lex</span>: <span class="nc">loop</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="sd">/*!re2c</span>
<span class="sd">        re2c:YYCTYPE = u8;</span>
<span class="sd">        re2c:yyfill:enable = 0;</span>

<span class="sd">        *      { return -1; }</span>
<span class="sd">        [\x00] { return count; }</span>
<span class="sd">        [a-z]+ { count += 1; continue &#39;lex; }</span>
<span class="sd">        [ ]+   { continue &#39;lex; }</span>
<span class="sd">    */</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">b&quot;</span><span class="se">\x00</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">b&quot;one two three</span><span class="se">\x00</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">b&quot;f0ur</span><span class="se">\x00</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="sentinel-with-bounds-checks">
<h3>Sentinel with bounds checks<a class="headerlink" href="#sentinel-with-bounds-checks" title="Permalink to this headline">¶</a></h3>
<p>This example uses sentinel with bounds checks to handle the end of input (this
method was added in version 1.2). The program counts space-separated
single-quoted strings. The sentinel character is null, which is specified with
<code class="docutils literal notranslate"><span class="pre">re2c:eof</span> <span class="pre">=</span> <span class="pre">0;</span></code> configuration. As in the <a class="reference internal" href="#sentinel">sentinel</a> method, null is the last
character of each input string, but it is allowed in the middle of a rule (for
example, <code class="docutils literal notranslate"><span class="pre">'aaa\0aa'\0</span></code> is valid input, but <code class="docutils literal notranslate"><span class="pre">'aaa\0</span></code> is a syntax error).
Bounds checks are generated in each state that matches an input character, but
they are scoped to the branch that handles null. Bounds checks are of the form
<code class="docutils literal notranslate"><span class="pre">YYLIMIT</span> <span class="pre">&lt;=</span> <span class="pre">YYCURSOR</span></code> or <code class="docutils literal notranslate"><span class="pre">YYLESSTHAN(1)</span></code> with generic API. If the check
condition is true, lexer has reached the end of input and should stop
(<code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> is disabled with <code class="docutils literal notranslate"><span class="pre">re2c:yyfill:enable</span> <span class="pre">=</span> <span class="pre">0;</span></code> as the input fits into
one buffer, see the <a class="reference internal" href="#yyfill-with-sentinel">YYFILL with sentinel</a> section for an example that uses
<code class="docutils literal notranslate"><span class="pre">YYFILL</span></code>). Reaching the end of input opens three possibilities: if the lexer
is in the initial state it will match the end-of-input rule <code class="docutils literal notranslate"><span class="pre">$</span></code>, otherwise it
may fallback to a previously matched rule (including default rule <code class="docutils literal notranslate"><span class="pre">*</span></code>) or go
to a default state, causing
<a class="reference external" href="https://re2c.org/manual/basics/warnings/warnings.html#wundefined-control-flow">-Wundefined-control-flow</a>.</p>
<p><a class="reference external" href="../../playground?example=rust/eof/03_eof_rule.re"><img alt="run_eof_03" class="feed" src="../_images/play.png" style="width: 2em;" /></a>   <a class="reference external" href="../../playground?example=rust/eof/03_eof_rule.re">Run in playground</a></p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2rust $INPUT -o $OUTPUT --api simple</span>

<span class="k">fn</span> <span class="nf">lex</span><span class="p">(</span><span class="n">yyinput</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="kt">isize</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// The input must be null-terminated, otherwise the function has UB.</span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">yyinput</span><span class="p">.</span><span class="n">last</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">0</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">yycursor</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">yymarker</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">yylimit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">yyinput</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// null-terminator not included</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="o">&#39;</span><span class="na">lex</span>: <span class="nc">loop</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="sd">/*!re2c</span>
<span class="sd">        re2c:YYCTYPE = u8;</span>
<span class="sd">        re2c:yyfill:enable = 0;</span>
<span class="sd">        re2c:eof = 0;</span>

<span class="sd">        str = [&#39;] ([^&#39;\\] | [\\][^])* [&#39;];</span>

<span class="sd">        *    { return -1; }</span>
<span class="sd">        $    { return count; }</span>
<span class="sd">        str  { count += 1; continue &#39;lex; }</span>
<span class="sd">        [ ]+ { continue &#39;lex; }</span>
<span class="sd">    */</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">b&quot;</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">b&quot;&#39;qu</span><span class="se">\0</span><span class="s">tes&#39; &#39;are&#39; &#39;fine: </span><span class="se">\\</span><span class="s">&#39;&#39; </span><span class="se">\0</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">b&quot;&#39;unterminated</span><span class="se">\\</span><span class="s">&#39;</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="bounds-checks-with-padding">
<h3>Bounds checks with padding<a class="headerlink" href="#bounds-checks-with-padding" title="Permalink to this headline">¶</a></h3>
<p>This example uses bounds checks with padding to handle the end of input (this
method is enabled by default). The program counts space-separated single-quoted
strings. There is a padding of <code class="docutils literal notranslate"><span class="pre">YYMAXFILL</span></code> null characters appended at the end
of input, where <code class="docutils literal notranslate"><span class="pre">YYMAXFILL</span></code> value is autogenerated with a <code class="docutils literal notranslate"><span class="pre">max</span></code> block. It
is not necessary to use null for padding — any characters can be used as long
as they do not form a valid lexeme suffix (in this example padding should not
contain single quotes, as they may be mistaken for a suffix of a single-quoted
string). There is a “stop” rule that matches the first padding character (null)
and terminates the lexer (note that it checks if null is at the beginning of
padding, otherwise it is a syntax error). Bounds checks are generated only in
some states that are determined by the strongly connected components of the
underlying automaton. Checks have the form <code class="docutils literal notranslate"><span class="pre">(YYLIMIT</span> <span class="pre">-</span> <span class="pre">YYCURSOR)</span> <span class="pre">&lt;</span> <span class="pre">n</span></code> or
<code class="docutils literal notranslate"><span class="pre">YYLESSTHAN(n)</span></code> with generic API, where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the minimum number of
characters that are needed for the lexer to proceed (it also means that the next
bounds check will occur in at most <code class="docutils literal notranslate"><span class="pre">n</span></code> characters). If the check condition is
true, the lexer has reached the end of input and will invoke <code class="docutils literal notranslate"><span class="pre">YYFILL(n)</span></code> that
should either supply at least <code class="docutils literal notranslate"><span class="pre">n</span></code> input characters or not return. In this
example <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> always fails and terminates the lexer with an error (which is
fine because the input fits into one buffer). See the <a class="reference internal" href="#yyfill-with-padding">YYFILL with padding</a>
section for an example that refills the input buffer with <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code>.</p>
<p><a class="reference external" href="../../playground?example=rust/eof/02_bounds_checking.re"><img alt="run_eof_02" class="feed" src="../_images/play.png" style="width: 2em;" /></a>   <a class="reference external" href="../../playground?example=rust/eof/02_bounds_checking.re">Run in playground</a></p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2rust $INPUT -o $OUTPUT --api simple</span>

<span class="sd">/*!max:re2c*/</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">lex</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="kt">isize</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">yycursor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">yylimit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">YYMAXFILL</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Copy string to a buffer and add YYMAXFILL zero padding.</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">yyinput</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">with_capacity</span><span class="p">(</span><span class="n">yylimit</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">yyinput</span><span class="p">.</span><span class="n">extend_from_slice</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">yyinput</span><span class="p">.</span><span class="n">extend</span><span class="p">([</span><span class="mi">0</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u8</span><span class="p">;</span><span class="w"> </span><span class="n">YYMAXFILL</span><span class="p">]);</span><span class="w"></span>

<span class="w">    </span><span class="o">&#39;</span><span class="na">lex</span>: <span class="nc">loop</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="sd">/*!re2c</span>
<span class="sd">        re2c:YYCTYPE = u8;</span>
<span class="sd">        re2c:YYFILL = &quot;return -1;&quot;;</span>

<span class="sd">        str = [&#39;] ([^&#39;\\] | [\\][^])* [&#39;];</span>

<span class="sd">        [\x00] {</span>
<span class="sd">            // Check that it is the sentinel, not some unexpected null.</span>
<span class="sd">            return if yycursor == s.len() + 1 { count } else { -1 }</span>
<span class="sd">        }</span>
<span class="sd">        str  { count += 1; continue &#39;lex; }</span>
<span class="sd">        [ ]+ { continue &#39;lex; }</span>
<span class="sd">        *    { return -1; }</span>
<span class="sd">    */</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">b&quot;&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">b&quot;&#39;qu</span><span class="se">\0</span><span class="s">tes&#39; &#39;are&#39; &#39;fine: </span><span class="se">\\</span><span class="s">&#39;&#39; &quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">b&quot;&#39;unterminated</span><span class="se">\\</span><span class="s">&#39;&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">b&quot;&#39;unexpected </span><span class="se">\0</span><span class="s"> null&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="custom-checks">
<h3>Custom checks<a class="headerlink" href="#custom-checks" title="Permalink to this headline">¶</a></h3>
<p>This example uses a custom end-of-input handling method based on generic API.
The program counts space-separated single-quoted strings. It is the same as the
<a class="reference internal" href="#sentinel">sentinel</a> example, except that the input is not null-terminated. To cover up
for the absence of a sentinel character at the end of input, <code class="docutils literal notranslate"><span class="pre">YYPEEK</span></code> is
redefined to perform a bounds check before it reads the next input character.
This is inefficient because checks are done very often. If the check condition
fails, <code class="docutils literal notranslate"><span class="pre">YYPEEK</span></code> returns the real character, otherwise it returns a fake
sentinel character.</p>
<p><a class="reference external" href="../../playground?example=rust/eof/04_fake_sentinel.re"><img alt="run_eof_04" class="feed" src="../_images/play.png" style="width: 2em;" /></a>   <a class="reference external" href="../../playground?example=rust/eof/04_fake_sentinel.re">Run in playground</a></p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2rust $INPUT -o $OUTPUT</span>

<span class="c1">// Expect a string without terminating null.</span>
<span class="k">fn</span> <span class="nf">lex</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="kt">isize</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">lim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">len</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="o">&#39;</span><span class="na">lex</span>: <span class="nc">loop</span><span class="w"> </span><span class="p">{</span><span class="sd">/*!re2c</span>
<span class="sd">        re2c:YYCTYPE = u8;</span>
<span class="sd">        re2c:YYPEEK = &quot;if cur &lt; lim {*s.get_unchecked(cur)} else {0}&quot;;</span>
<span class="sd">        re2c:YYSKIP = &quot;cur += 1;&quot;;</span>
<span class="sd">        re2c:yyfill:enable  = 0;</span>

<span class="sd">        *      { return -1; }</span>
<span class="sd">        [\x00] { return count; }</span>
<span class="sd">        [a-z]+ { count += 1; continue &#39;lex; }</span>
<span class="sd">        [ ]+   { continue &#39;lex; }</span>
<span class="sd">    */</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">b&quot;&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">b&quot;one two three &quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">b&quot;f0ur&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="buffer-refilling">
<h2>Buffer refilling<a class="headerlink" href="#buffer-refilling" title="Permalink to this headline">¶</a></h2>
<p>The need for buffering arises when the input cannot be mapped in memory all at
once: either it is too large, or it comes in a streaming fashion (like reading
from a socket). The usual technique in such cases is to allocate a fixed-sized
memory buffer and process input in chunks that fit into the buffer. When the
current chunk is processed, it is moved out and new data is moved in. In
practice it is somewhat more complex, because lexer state consists not of a
single input position, but a set of interrelated positions:</p>
<ul class="simple">
<li><p>cursor: the next input character to be read (<code class="docutils literal notranslate"><span class="pre">YYCURSOR</span></code> in C pointer API or
<code class="docutils literal notranslate"><span class="pre">YYSKIP</span></code>/<code class="docutils literal notranslate"><span class="pre">YYPEEK</span></code> in generic API)</p></li>
<li><p>limit: the position after the last available input character (<code class="docutils literal notranslate"><span class="pre">YYLIMIT</span></code> in
C pointer API, implicitly handled by <code class="docutils literal notranslate"><span class="pre">YYLESSTHAN</span></code> in generic API)</p></li>
<li><p>marker: the position of the most recent match, if any (<code class="docutils literal notranslate"><span class="pre">YYMARKER</span></code> in default
API or <code class="docutils literal notranslate"><span class="pre">YYBACKUP</span></code>/<code class="docutils literal notranslate"><span class="pre">YYRESTORE</span></code> in generic API)</p></li>
<li><p>token: the start of the current lexeme (implicit in re2rust API, as it is not
needed for the normal lexer operation and can be defined and updated by the
user)</p></li>
<li><p>context marker: the position of the trailing context (<code class="docutils literal notranslate"><span class="pre">YYCTXMARKER</span></code> in
C pointer API or <code class="docutils literal notranslate"><span class="pre">YYBACKUPCTX</span></code>/<code class="docutils literal notranslate"><span class="pre">YYRESTORECTX</span></code> in generic API)</p></li>
<li><p>tag variables: submatch positions (defined with <code class="docutils literal notranslate"><span class="pre">stags</span></code> and <code class="docutils literal notranslate"><span class="pre">mtags</span></code> blocks
and generic API primitives <code class="docutils literal notranslate"><span class="pre">YYSTAGP</span></code>/<code class="docutils literal notranslate"><span class="pre">YYSTAGN</span></code>/<code class="docutils literal notranslate"><span class="pre">YYMTAGP</span></code>/<code class="docutils literal notranslate"><span class="pre">YYMTAGN</span></code>)</p></li>
</ul>
<p>Not all these are used in every case, but if used, they must be updated by
<code class="docutils literal notranslate"><span class="pre">YYFILL</span></code>. All active positions are contained in the segment between token and
cursor, therefore everything between buffer start and token can be discarded,
the segment from token and up to limit should be moved to the beginning of
buffer, and the free space at the end of buffer should be filled with new data.
In order to avoid frequent <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> calls it is best to fill in as many input
characters as possible (even though fewer characters might suffice to resume the
lexer). The details of <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> implementation are slightly different
depending on which EOF handling method is used: the case of EOF rule is somewhat
simpler than the case of bounds-checking with padding. Also note that if
<code class="docutils literal notranslate"><span class="pre">-f</span> <span class="pre">--storable-state</span></code> option is used, <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> has slightly different
semantics (described in the section about storable state).</p>
<section id="yyfill-with-sentinel">
<h3>YYFILL with sentinel<a class="headerlink" href="#yyfill-with-sentinel" title="Permalink to this headline">¶</a></h3>
<p>If EOF rule is used, <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> is a function-like primitive that accepts
no arguments and returns a value which is checked against zero. <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code>
invocation is triggered by condition <code class="docutils literal notranslate"><span class="pre">YYLIMIT</span> <span class="pre">&lt;=</span> <span class="pre">YYCURSOR</span></code> in C pointer API and
<code class="docutils literal notranslate"><span class="pre">YYLESSTHAN()</span></code> in generic API. A non-zero return value means that <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code>
has failed. A successful <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> call must supply at least one character and
adjust input positions accordingly. Limit must always be set to one after the
last input position in buffer, and the character at the limit position must be
the sentinel symbol specified by <code class="docutils literal notranslate"><span class="pre">re2c:eof</span></code> configuration. The pictures below
show the relative locations of input positions in buffer before and after
<code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> call (sentinel symbol is marked with <code class="docutils literal notranslate"><span class="pre">#</span></code>, and the second picture
shows the case when there is not enough input to fill the whole buffer).</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>               &lt;-- shift --&gt;
             &gt;-A------------B---------C-------------D#-----------E-&gt;
             buffer       token    marker         limit,
                                                  cursor
&gt;-A------------B---------C-------------D------------E#-&gt;
             buffer,  marker        cursor        limit
             token

               &lt;-- shift --&gt;
             &gt;-A------------B---------C-------------D#--E (EOF)
             buffer       token    marker         limit,
                                                  cursor
&gt;-A------------B---------C-------------D---E#........
             buffer,  marker       cursor limit
             token
</pre></div>
</div>
<p>Here is an example of a program that reads input file <code class="docutils literal notranslate"><span class="pre">input.txt</span></code> in chunks of
4096 bytes and uses EOF rule.</p>
<p><a class="reference external" href="../../playground?example=rust/fill/01_fill.re"><img alt="run_fill_01" class="feed" src="../_images/play.png" style="width: 2em;" /></a>   <a class="reference external" href="../../playground?example=rust/fill/01_fill.re">Run in playground</a></p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2rust $INPUT -o $OUTPUT</span>

<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="p">{</span><span class="n">Read</span><span class="p">,</span><span class="w"> </span><span class="n">Write</span><span class="p">};</span><span class="w"></span>

<span class="k">const</span><span class="w"> </span><span class="n">BUFSIZE</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="mi">4096</span><span class="p">;</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">State</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">file</span>: <span class="nc">File</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">yyinput</span>: <span class="p">[</span><span class="kt">u8</span><span class="p">;</span><span class="w"> </span><span class="n">BUFSIZE</span><span class="p">],</span><span class="w"></span>
<span class="w">    </span><span class="n">yylimit</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">yycursor</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">yymarker</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">token</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">eof</span>: <span class="kt">bool</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#[derive(PartialEq)]</span><span class="w"></span>
<span class="k">enum</span> <span class="nc">Fill</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">Ok</span><span class="p">,</span><span class="w"> </span><span class="n">Eof</span><span class="p">,</span><span class="w"> </span><span class="n">LongLexeme</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">fill</span><span class="p">(</span><span class="n">st</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">State</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Fill</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">st</span><span class="p">.</span><span class="n">eof</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">Fill</span>::<span class="n">Eof</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Error: lexeme too long. In real life could reallocate a larger buffer.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">st</span><span class="p">.</span><span class="n">token</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">Fill</span>::<span class="n">LongLexeme</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Shift buffer contents (discard everything up to the current token).</span>
<span class="w">    </span><span class="n">st</span><span class="p">.</span><span class="n">yyinput</span><span class="p">.</span><span class="n">copy_within</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">token</span><span class="o">..</span><span class="n">st</span><span class="p">.</span><span class="n">yylimit</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">st</span><span class="p">.</span><span class="n">yylimit</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">st</span><span class="p">.</span><span class="n">token</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">st</span><span class="p">.</span><span class="n">yycursor</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">st</span><span class="p">.</span><span class="n">token</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">st</span><span class="p">.</span><span class="n">yymarker</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st</span><span class="p">.</span><span class="n">yymarker</span><span class="p">.</span><span class="n">overflowing_sub</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">token</span><span class="p">).</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// may underflow if marker is unused</span>
<span class="w">    </span><span class="n">st</span><span class="p">.</span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Fill free space at the end of buffer with new data from file.</span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">st</span><span class="p">.</span><span class="n">file</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">st</span><span class="p">.</span><span class="n">yyinput</span><span class="p">[</span><span class="n">st</span><span class="p">.</span><span class="n">yylimit</span><span class="o">..</span><span class="n">BUFSIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// -1 for sentinel</span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">st</span><span class="p">.</span><span class="n">yylimit</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">st</span><span class="p">.</span><span class="n">eof</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// end of file</span>
<span class="w">            </span><span class="n">st</span><span class="p">.</span><span class="n">yyinput</span><span class="p">[</span><span class="n">st</span><span class="p">.</span><span class="n">yylimit</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// append sentinel</span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">why</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&quot;cannot read from file: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">why</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Fill</span>::<span class="nb">Ok</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">lex</span><span class="p">(</span><span class="n">yyrecord</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">State</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">isize</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">count</span>: <span class="kt">isize</span> <span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="o">&#39;</span><span class="na">lex</span>: <span class="nc">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">yyrecord</span><span class="p">.</span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">yyrecord</span><span class="p">.</span><span class="n">yycursor</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="sd">/*!re2c</span>
<span class="sd">        re2c:api = record;</span>
<span class="sd">        re2c:YYCTYPE = u8;</span>
<span class="sd">        re2c:YYFILL = &quot;fill(yyrecord) == Fill::Ok&quot;;</span>
<span class="sd">        re2c:eof = 0;</span>

<span class="sd">        str = [&#39;] ([^&#39;\\] | [\\][^])* [&#39;];</span>

<span class="sd">        *    { return -1; }</span>
<span class="sd">        $    { return count; }</span>
<span class="sd">        str  { count += 1; continue &#39;lex; }</span>
<span class="sd">        [ ]+ { continue &#39;lex; }</span>
<span class="sd">    */</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">fname</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;input&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">content</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">b&quot;&#39;qu</span><span class="se">\0</span><span class="s">tes&#39; &#39;are&#39; &#39;fine: </span><span class="se">\\</span><span class="s">&#39;&#39; &quot;</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Prepare input file: a few times the size of the buffer, containing</span>
<span class="w">    </span><span class="c1">// strings with zeroes and escaped quotes.</span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">File</span>::<span class="n">create</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">why</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&quot;cannot open {}: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fname</span><span class="p">,</span><span class="w"> </span><span class="n">why</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">file</span><span class="p">.</span><span class="n">write_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">content</span><span class="p">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">BUFSIZE</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">Err</span><span class="p">(</span><span class="n">why</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&quot;cannot write to {}: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fname</span><span class="p">,</span><span class="w"> </span><span class="n">why</span><span class="p">),</span><span class="w"></span>
<span class="w">            </span><span class="nb">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">BUFSIZE</span><span class="p">;</span><span class="w"> </span><span class="c1">// number of quoted strings written to file</span>

<span class="w">    </span><span class="c1">// Reopen input file for reading.</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">why</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&quot;cannot read file {}: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fname</span><span class="p">,</span><span class="w"> </span><span class="n">why</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">file</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Initialize lexer state: all offsets are at the end of buffer.</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">yylimit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BUFSIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">st</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">State</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">file</span>: <span class="nc">file</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Sentinel (at `yylimit` offset) is set to null, which triggers YYFILL.</span>
<span class="w">        </span><span class="n">yyinput</span>: <span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">BUFSIZE</span><span class="p">],</span><span class="w"></span>
<span class="w">        </span><span class="n">yylimit</span>: <span class="nc">yylimit</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">yycursor</span>: <span class="nc">yylimit</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">yymarker</span>: <span class="nc">yylimit</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">token</span>: <span class="nc">yylimit</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">eof</span>: <span class="nc">false</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Run the lexer.</span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">st</span><span class="p">),</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">isize</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Cleanup: remove input file.</span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">remove_file</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">why</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&quot;cannot remove {}: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fname</span><span class="p">,</span><span class="w"> </span><span class="n">why</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="yyfill-with-padding">
<h3>YYFILL with padding<a class="headerlink" href="#yyfill-with-padding" title="Permalink to this headline">¶</a></h3>
<p>In the default case (when EOF rule is not used) <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> is a function-like
primitive that accepts a single argument and does not return any value.
<code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> invocation is triggered by condition <code class="docutils literal notranslate"><span class="pre">(YYLIMIT</span> <span class="pre">-</span> <span class="pre">YYCURSOR)</span> <span class="pre">&lt;</span> <span class="pre">n</span></code> in
C pointer API and <code class="docutils literal notranslate"><span class="pre">YYLESSTHAN(n)</span></code> in generic API. The argument passed to
<code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> is the minimal number of characters that must be supplied. If it
fails to do so, <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> must not return to the lexer (for that reason it is
best implemented as a macro that returns from the calling function on failure).
In case of a successful <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> invocation the limit position must be set
either to one after the last input position in buffer, or to the end of
<code class="docutils literal notranslate"><span class="pre">YYMAXFILL</span></code> padding (in case <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> has successfully read at least <code class="docutils literal notranslate"><span class="pre">n</span></code>
characters, but not enough to fill the entire buffer). The pictures below show
the relative locations of input positions in buffer before and after <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code>
invocation (<code class="docutils literal notranslate"><span class="pre">YYMAXFILL</span></code> padding on the second picture is marked with <code class="docutils literal notranslate"><span class="pre">#</span></code>
symbols).</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>               &lt;-- shift --&gt;                 &lt;-- need --&gt;
             &gt;-A------------B---------C-----D-------E---F--------G-&gt;
             buffer       token    marker cursor  limit

&gt;-A------------B---------C-----D-------E---F--------G-&gt;
             buffer,  marker cursor               limit
             token

               &lt;-- shift --&gt;                 &lt;-- need --&gt;
             &gt;-A------------B---------C-----D-------E-F        (EOF)
             buffer       token    marker cursor  limit

&gt;-A------------B---------C-----D-------E-F###############
             buffer,  marker cursor                   limit
             token                        &lt;- YYMAXFILL -&gt;
</pre></div>
</div>
<p>Here is an example of a program that reads input file <code class="docutils literal notranslate"><span class="pre">input.txt</span></code> in chunks of
4096 bytes and uses bounds-checking with padding.</p>
<p><a class="reference external" href="../../playground?example=rust/fill/02_fill.re"><img alt="run_fill_02" class="feed" src="../_images/play.png" style="width: 2em;" /></a>   <a class="reference external" href="../../playground?example=rust/fill/02_fill.re">Run in playground</a></p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2rust $INPUT -o $OUTPUT</span>

<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="p">{</span><span class="n">Read</span><span class="p">,</span><span class="w"> </span><span class="n">Write</span><span class="p">};</span><span class="w"></span>

<span class="sd">/*!max:re2c*/</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">BUFSIZE</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="mi">4096</span><span class="p">;</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">State</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">file</span>: <span class="nc">File</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">yyinput</span>: <span class="p">[</span><span class="kt">u8</span><span class="p">;</span><span class="w"> </span><span class="n">BUFSIZE</span><span class="p">],</span><span class="w"></span>
<span class="w">    </span><span class="n">yylimit</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">yycursor</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">yymarker</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">token</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">eof</span>: <span class="kt">bool</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#[derive(PartialEq)]</span><span class="w"></span>
<span class="k">enum</span> <span class="nc">Fill</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">Ok</span><span class="p">,</span><span class="w"> </span><span class="n">Eof</span><span class="p">,</span><span class="w"> </span><span class="n">LongLexeme</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">fill</span><span class="p">(</span><span class="n">st</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">State</span><span class="p">,</span><span class="w"> </span><span class="n">need</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Fill</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">st</span><span class="p">.</span><span class="n">eof</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">Fill</span>::<span class="n">Eof</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Error: lexeme too long. In real life can reallocate a larger buffer.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">st</span><span class="p">.</span><span class="n">token</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">need</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">Fill</span>::<span class="n">LongLexeme</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Shift buffer contents (discard everything up to the current token).</span>
<span class="w">    </span><span class="n">st</span><span class="p">.</span><span class="n">yyinput</span><span class="p">.</span><span class="n">copy_within</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">token</span><span class="o">..</span><span class="n">st</span><span class="p">.</span><span class="n">yylimit</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">st</span><span class="p">.</span><span class="n">yylimit</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">st</span><span class="p">.</span><span class="n">token</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">st</span><span class="p">.</span><span class="n">yycursor</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">st</span><span class="p">.</span><span class="n">token</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">st</span><span class="p">.</span><span class="n">yymarker</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st</span><span class="p">.</span><span class="n">yymarker</span><span class="p">.</span><span class="n">overflowing_sub</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">token</span><span class="p">).</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// underflows if marker is unused</span>
<span class="w">    </span><span class="n">st</span><span class="p">.</span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Fill free space at the end of buffer with new data from file.</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">st</span><span class="p">.</span><span class="n">file</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">st</span><span class="p">.</span><span class="n">yyinput</span><span class="p">[</span><span class="n">st</span><span class="p">.</span><span class="n">yylimit</span><span class="o">..</span><span class="n">BUFSIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">YYMAXFILL</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">why</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&quot;cannot read from file: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">why</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="n">st</span><span class="p">.</span><span class="n">yylimit</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// If read zero characters, this is end of input =&gt; add zero padding</span>
<span class="w">    </span><span class="c1">// so that the lexer can access characters at the end of buffer.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">st</span><span class="p">.</span><span class="n">eof</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">YYMAXFILL</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">st</span><span class="p">.</span><span class="n">yyinput</span><span class="p">[</span><span class="n">st</span><span class="p">.</span><span class="n">yylimit</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">st</span><span class="p">.</span><span class="n">yylimit</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">YYMAXFILL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Fill</span>::<span class="nb">Ok</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">lex</span><span class="p">(</span><span class="n">yyrecord</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">State</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">isize</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">count</span>: <span class="kt">isize</span> <span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="o">&#39;</span><span class="na">lex</span>: <span class="nc">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">yyrecord</span><span class="p">.</span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">yyrecord</span><span class="p">.</span><span class="n">yycursor</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="sd">/*!re2c</span>
<span class="sd">        re2c:api = record;</span>
<span class="sd">        re2c:YYCTYPE = u8;</span>
<span class="sd">        re2c:YYFILL = &quot;if fill(yyrecord, @@) != Fill::Ok { return -1; }&quot;;</span>

<span class="sd">        str = [&#39;] ([^&#39;\\] | [\\][^])* [&#39;];</span>

<span class="sd">        [\x00] {</span>
<span class="sd">            // Check that it is the sentinel, not some unexpected null.</span>
<span class="sd">            return if yyrecord.token == yyrecord.yylimit - YYMAXFILL { count } else { -1 }</span>
<span class="sd">        }</span>
<span class="sd">        str  { count += 1; continue &#39;lex; }</span>
<span class="sd">        [ ]+ { continue &#39;lex; }</span>
<span class="sd">        *    { return -1; }</span>
<span class="sd">    */</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">fname</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;input&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">content</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">b&quot;&#39;qu</span><span class="se">\0</span><span class="s">tes&#39; &#39;are&#39; &#39;fine: </span><span class="se">\\</span><span class="s">&#39;&#39; &quot;</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Prepare input file: a few times the size of the buffer, containing</span>
<span class="w">    </span><span class="c1">// strings with zeroes and escaped quotes.</span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">File</span>::<span class="n">create</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">why</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&quot;cannot open {}: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fname</span><span class="p">,</span><span class="w"> </span><span class="n">why</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">file</span><span class="p">.</span><span class="n">write_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">content</span><span class="p">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">BUFSIZE</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">Err</span><span class="p">(</span><span class="n">why</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&quot;cannot write to {}: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fname</span><span class="p">,</span><span class="w"> </span><span class="n">why</span><span class="p">),</span><span class="w"></span>
<span class="w">            </span><span class="nb">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">BUFSIZE</span><span class="p">;</span><span class="w"> </span><span class="c1">// number of quoted strings written to file</span>

<span class="w">    </span><span class="c1">// Reopen input file for reading.</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">why</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&quot;cannot read file {}: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fname</span><span class="p">,</span><span class="w"> </span><span class="n">why</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">file</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Initialize lexer state: all offsets are at the end of buffer.</span>
<span class="w">    </span><span class="c1">// This immediately triggers YYFILL, as the YYLESSTHAN condition is true.</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">yylimit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BUFSIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">YYMAXFILL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">st</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">State</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">file</span>: <span class="nc">file</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">yyinput</span>: <span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">BUFSIZE</span><span class="p">],</span><span class="w"></span>
<span class="w">        </span><span class="n">yylimit</span>: <span class="nc">yylimit</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">yycursor</span>: <span class="nc">yylimit</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">yymarker</span>: <span class="nc">yylimit</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">token</span>: <span class="nc">yylimit</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">eof</span>: <span class="nc">false</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Run the lexer.</span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">st</span><span class="p">),</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">isize</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Cleanup: remove input file.</span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">remove_file</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">why</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&quot;cannot remove {}: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fname</span><span class="p">,</span><span class="w"> </span><span class="n">why</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="features">
<h2>Features<a class="headerlink" href="#features" title="Permalink to this headline">¶</a></h2>
<section id="multiple-blocks">
<h3>Multiple blocks<a class="headerlink" href="#multiple-blocks" title="Permalink to this headline">¶</a></h3>
<p>Sometimes it is necessary to have multiple interrelated lexers (for example, if
there is a high-level state machine that transitions between lexer modes). This
can be implemented using multiple connected re2rust blocks. Another option is to
use <a class="reference internal" href="#start-conditions">start conditions</a>.</p>
<p>The implementation of connections between blocks depends on the target language.
In languages that have <code class="docutils literal notranslate"><span class="pre">goto</span></code> statement (such as C/C++ and Go) one can have
all blocks in one function, each of them prefixed with a label. Transition from
one block to another is a simple <code class="docutils literal notranslate"><span class="pre">goto</span></code>.
In languages that do not have <code class="docutils literal notranslate"><span class="pre">goto</span></code> (such as Rust) it is necessary to use a
loop with a switch on a state variable, similar to the <code class="docutils literal notranslate"><span class="pre">yystate</span></code> loop/switch
generated by re2rust, or else wrap each block in a function and use function calls.</p>
<p>The example below uses multiple blocks to parse binary, octal, decimal and
hexadecimal numbers. Each base has its own block. The initial block determines
base and dispatches to other blocks. Common configurations are defined in a
separate block at the beginning of the program; they are inherited by the other
blocks.</p>
<p><a class="reference external" href="../../playground?example=rust/conditions/parse_u32_blocks.re"><img alt="run_cond_blocks" class="feed" src="../_images/play.png" style="width: 2em;" /></a>   <a class="reference external" href="../../playground?example=rust/conditions/parse_u32_blocks.re">Run in playground</a></p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2rust $INPUT -o $OUTPUT</span>

<span class="c1">// Store u32 number in u64 during parsing to simplify overflow handling.</span>
<span class="k">struct</span> <span class="nc">State</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">yyinput</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="p">[</span><span class="kt">u8</span><span class="p">],</span><span class="w"></span>
<span class="w">    </span><span class="n">yycursor</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">yymarker</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">num</span>: <span class="kt">u64</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="sd">/*!re2c // Common re2c definitions shared between all functions.</span>
<span class="sd">    re2c:api = record;</span>
<span class="sd">    re2c:yyrecord = st;</span>
<span class="sd">    re2c:yyfill:enable = 0;</span>
<span class="sd">    re2c:YYCTYPE = u8;</span>
<span class="sd">*/</span><span class="w"></span>

<span class="k">const</span><span class="w"> </span><span class="n">ERROR</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="kt">u32</span>::<span class="n">MAX</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u64</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// overflow</span>

<span class="fm">macro_rules!</span><span class="w"> </span><span class="n">maybe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Convert the number from u64 to optional u32.</span>
<span class="w">    </span><span class="p">(</span><span class="cp">$n</span>:<span class="nc">expr</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="cp">$n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ERROR</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="cp">$n</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">None</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Add digit with the given base, checking for overflow.</span>
<span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="n">st</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">State</span><span class="p">,</span><span class="w"> </span><span class="n">offs</span>: <span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">base</span>: <span class="kt">u64</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">digit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">st</span><span class="p">.</span><span class="n">yyinput</span><span class="p">.</span><span class="n">get_unchecked</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">yycursor</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">offs</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">st</span><span class="p">.</span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">cmp</span>::<span class="n">min</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">num</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">digit</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u64</span><span class="p">,</span><span class="w"> </span><span class="n">ERROR</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">parse_u32</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span> <span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">last</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">0</span><span class="p">));</span><span class="w"> </span><span class="c1">// expect null-terminated input</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">st</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">State</span><span class="w"> </span><span class="p">{</span><span class="n">yyinput</span>: <span class="nc">s</span><span class="p">,</span><span class="w"> </span><span class="n">yycursor</span>: <span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">yymarker</span>: <span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">num</span>: <span class="mi">0</span><span class="p">};</span><span class="w"></span>
<span class="sd">/*!re2c</span>
<span class="sd">    &#39;0b&#39; / [01]        { return parse_bin(&amp;mut st); }</span>
<span class="sd">    &quot;0&quot;                { return parse_oct(&amp;mut st); }</span>
<span class="sd">    &quot;&quot; / [1-9]         { return parse_dec(&amp;mut st); }</span>
<span class="sd">    &#39;0x&#39; / [0-9a-fA-F] { return parse_hex(&amp;mut st); }</span>
<span class="sd">    *                  { return None; }</span>
<span class="sd">*/</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">parse_bin</span><span class="p">(</span><span class="n">st</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">State</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="o">&#39;</span><span class="na">bin</span>: <span class="nc">loop</span><span class="w"> </span><span class="p">{</span><span class="sd">/*!re2c</span>
<span class="sd">        [01] { add(st, 48, 2); continue &#39;bin; }</span>
<span class="sd">        *    { return maybe!(st.num); }</span>
<span class="sd">    */</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">parse_oct</span><span class="p">(</span><span class="n">st</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">State</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="o">&#39;</span><span class="na">oct</span>: <span class="nc">loop</span><span class="w"> </span><span class="p">{</span><span class="sd">/*!re2c</span>
<span class="sd">        [0-7] { add(st, 48, 8); continue &#39;oct; }</span>
<span class="sd">        *     { return maybe!(st.num); }</span>
<span class="sd">    */</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">parse_dec</span><span class="p">(</span><span class="n">st</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">State</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="o">&#39;</span><span class="na">dec</span>: <span class="nc">loop</span><span class="w"> </span><span class="p">{</span><span class="sd">/*!re2c</span>
<span class="sd">        [0-9] { add(st, 48, 10); continue &#39;dec; }</span>
<span class="sd">        *     { return maybe!(st.num); }</span>
<span class="sd">    */</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">parse_hex</span><span class="p">(</span><span class="n">st</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">State</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="o">&#39;</span><span class="na">hex</span>: <span class="nc">loop</span><span class="w"> </span><span class="p">{</span><span class="sd">/*!re2c</span>
<span class="sd">        [0-9] { add(st, 48, 16); continue &#39;hex; }</span>
<span class="sd">        [a-f] { add(st, 87, 16); continue &#39;hex; }</span>
<span class="sd">        [A-F] { add(st, 55, 16); continue &#39;hex; }</span>
<span class="sd">        *     { return maybe!(st.num); }</span>
<span class="sd">    */</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">parse_u32</span><span class="p">(</span><span class="s">b&quot;</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">parse_u32</span><span class="p">(</span><span class="s">b&quot;1234567890</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">1234567890</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">parse_u32</span><span class="p">(</span><span class="s">b&quot;0b1101</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">13</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">parse_u32</span><span class="p">(</span><span class="s">b&quot;0x7Fe</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">2046</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">parse_u32</span><span class="p">(</span><span class="s">b&quot;0644</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">420</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">parse_u32</span><span class="p">(</span><span class="s">b&quot;9999999999</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="start-conditions">
<h3>Start conditions<a class="headerlink" href="#start-conditions" title="Permalink to this headline">¶</a></h3>
<p>Start conditions are enabled with <code class="docutils literal notranslate"><span class="pre">--start-conditions</span></code> option. They provide a
way to encode multiple interrelated automata within the same re2rust block.</p>
<p>Each condition corresponds to a single automaton and has a unique name specified
by the user and a unique internal number defined by re2rust. The numbers are used
to switch between conditions: the generated code uses <code class="docutils literal notranslate"><span class="pre">YYGETCOND</span></code> and
<code class="docutils literal notranslate"><span class="pre">YYSETCOND</span></code> primitives to get the current condition or set it to the
given number. Use <code class="docutils literal notranslate"><span class="pre">conditions</span></code> block, <code class="docutils literal notranslate"><span class="pre">--header</span></code> option or <code class="docutils literal notranslate"><span class="pre">re2c:header</span></code>
configuration to generate numeric condition identifiers. Configuration
<code class="docutils literal notranslate"><span class="pre">re2c:cond:enumprefix</span></code> specifies the generated identifier prefix.</p>
<p>In condition mode every rule must be prefixed with a list of comma-separated
condition names in angle brackets, or a wildcard <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code> to denote all
conditions. The rule syntax is extended as follows:</p>
<blockquote>
<div><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;</span> <span class="pre">condition-list</span> <span class="pre">&gt;</span> <span class="pre">regular-expression</span> <span class="pre">code</span></code></dt><dd><p>A rule that is merged to every condition on the <code class="docutils literal notranslate"><span class="pre">condition-list</span></code>.
It matches <code class="docutils literal notranslate"><span class="pre">regular-expression</span></code> and executes the associated <code class="docutils literal notranslate"><span class="pre">code</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;</span> <span class="pre">condition-list</span> <span class="pre">&gt;</span> <span class="pre">regular-expression</span> <span class="pre">=&gt;</span> <span class="pre">condition</span> <span class="pre">code</span></code></dt><dd><p>A rule that is merged to every condition on the <code class="docutils literal notranslate"><span class="pre">condition-list</span></code>.
It matches <code class="docutils literal notranslate"><span class="pre">regular-expression</span></code>, sets the current condition to
<code class="docutils literal notranslate"><span class="pre">condition</span></code> and executes the associated <code class="docutils literal notranslate"><span class="pre">code</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;</span> <span class="pre">condition-list</span> <span class="pre">&gt;</span> <span class="pre">regular-expression</span> <span class="pre">:=&gt;</span> <span class="pre">condition</span></code></dt><dd><p>A rule that is merged to every condition on the <code class="docutils literal notranslate"><span class="pre">condition-list</span></code>.
It matches <code class="docutils literal notranslate"><span class="pre">regular-expression</span></code> and immediately transitions to
<code class="docutils literal notranslate"><span class="pre">condition</span></code> (there is no semantic action).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;</span> <span class="pre">condition-list</span> <span class="pre">&gt;</span> <span class="pre">!action</span> <span class="pre">code</span></code></dt><dd><p>A rule that binds <code class="docutils literal notranslate"><span class="pre">code</span></code> to the place defined by <code class="docutils literal notranslate"><span class="pre">action</span></code> in every
condition on the <code class="docutils literal notranslate"><span class="pre">condition-list</span></code> (see the <a class="reference internal" href="#actions">actions</a> section for
various types of actions).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;!</span> <span class="pre">condition-list</span> <span class="pre">&gt;</span> <span class="pre">code</span></code></dt><dd><p>A rule that prepends <code class="docutils literal notranslate"><span class="pre">code</span></code> to semantic actions of all rules for every
condition on the <code class="docutils literal notranslate"><span class="pre">condition-list</span></code>. This syntax is deprecated and the
<code class="docutils literal notranslate"><span class="pre">!pre_rule</span></code> action should be used instead (it does exactly the same).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;</span> <span class="pre">&gt;</span> <span class="pre">code</span></code></dt><dd><p>A rule that creates a special entry condition with number zero and name
<code class="docutils literal notranslate"><span class="pre">&quot;0&quot;</span></code> that executes <code class="docutils literal notranslate"><span class="pre">code</span></code> before jumping to other conditions.
This syntax is deprecated, and the <code class="docutils literal notranslate"><span class="pre">!entry</span></code> action should be used
instead (it provides a more fine-grained control, as the code can be
specified on a per-condition basis, and one can jump directly to
condition start without going through condition dispatch).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;</span> <span class="pre">&gt;</span> <span class="pre">=&gt;</span> <span class="pre">condition</span> <span class="pre">code</span></code></dt><dd><p>Same as the previous rule, except that it sets the next <code class="docutils literal notranslate"><span class="pre">condition</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;</span> <span class="pre">&gt;</span> <span class="pre">:=&gt;</span> <span class="pre">condition</span></code></dt><dd><p>Same as the previous rule, except that it has no associated code and
immediately jumps to <code class="docutils literal notranslate"><span class="pre">condition</span></code>.</p>
</dd>
</dl>
</div></blockquote>
<p>The code re2rust generates for conditions depends on whether re2rust uses
goto/label approach or loop/switch approach to encode the automata.</p>
<p>In languages that have <code class="docutils literal notranslate"><span class="pre">goto</span></code> statement (such as C/C++ and Go) conditions are
naturally implemented as blocks of code prefixed with labels of the form
<code class="docutils literal notranslate"><span class="pre">yyc_&lt;cond&gt;</span></code>, where <code class="docutils literal notranslate"><span class="pre">cond</span></code> is a condition name (label prefix can be changed
with <code class="docutils literal notranslate"><span class="pre">re2c:cond:prefix</span></code>). Transitions between conditions are implemented using
<code class="docutils literal notranslate"><span class="pre">goto</span></code> and condition labels. Before all conditions re2rust generates an initial
switch on <code class="docutils literal notranslate"><span class="pre">YYGETSTATE</span></code> that jumps to the start state of the current condition.
The shortcut rules <code class="docutils literal notranslate"><span class="pre">:=&gt;</span></code> bypass the initial switch and jump directly to the
specified condition (<code class="docutils literal notranslate"><span class="pre">re2c:cond:goto</span></code> can be used to change the default
behavior). The rules with semantic actions do not automatically jump to the next
condition; this should be done by the user-defined action code.</p>
<p>In languages that do not have <code class="docutils literal notranslate"><span class="pre">goto</span></code> (such as Rust) re2rust reuses the
<code class="docutils literal notranslate"><span class="pre">yystate</span></code> variable to store condition numbers. Each condition gets a numeric
identifier equal to the number of its start state, and a switch between
conditions is no different than a switch between DFA states of a single
condition. There is no need for a separate initial condition switch.
(Since the same approach is used to implement storable states,
<code class="docutils literal notranslate"><span class="pre">YYGETCOND</span></code>/<code class="docutils literal notranslate"><span class="pre">YYSETCOND</span></code> are redundant if both storable states and
conditions are used).</p>
<p>The program below uses start conditions to parse binary, octal, decimal and
hexadecimal numbers. There is a single block where each base has its own
condition, and the initial condition is connected to all of them. User-defined
variable <code class="docutils literal notranslate"><span class="pre">cond</span></code> stores the current condition number; it is initialized to the
number of the initial condition generated with <code class="docutils literal notranslate"><span class="pre">conditions</span></code> block.</p>
<p><a class="reference external" href="../../playground?example=rust/conditions/parse_u32_conditions.re"><img alt="run_cond_conds" class="feed" src="../_images/play.png" style="width: 2em;" /></a>   <a class="reference external" href="../../playground?example=rust/conditions/parse_u32_conditions.re">Run in playground</a></p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2rust $INPUT -o $OUTPUT -c --api simple</span>

<span class="sd">/*!conditions:re2c*/</span><span class="w"></span>

<span class="k">const</span><span class="w"> </span><span class="n">ERROR</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="kt">u32</span>::<span class="n">MAX</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u64</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// overflow</span>

<span class="c1">// Add digit with the given base, checking for overflow.</span>
<span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="n">num</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="kt">u64</span><span class="p">,</span><span class="w"> </span><span class="kt">str</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">],</span><span class="w"> </span><span class="n">cur</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">offs</span>: <span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">base</span>: <span class="kt">u64</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">digit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">str</span><span class="p">.</span><span class="n">get_unchecked</span><span class="p">(</span><span class="n">cur</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">offs</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="o">*</span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">cmp</span>::<span class="n">min</span><span class="p">(</span><span class="o">*</span><span class="n">num</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">digit</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u64</span><span class="p">,</span><span class="w"> </span><span class="n">ERROR</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">parse_u32</span><span class="p">(</span><span class="n">yyinput</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">yyinput</span><span class="p">.</span><span class="n">last</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">0</span><span class="p">));</span><span class="w"> </span><span class="c1">// expect null-terminated input</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">yycursor</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">yymarker</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">yycond</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">YYC_INIT</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="k">u64</span><span class="p">;</span><span class="w"> </span><span class="c1">// Store number in u64 to simplify overflow checks.</span>

<span class="w">    </span><span class="o">&#39;</span><span class="na">lex</span>: <span class="nc">loop</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="sd">/*!re2c</span>
<span class="sd">        re2c:YYCTYPE = u8;</span>
<span class="sd">        re2c:yyfill:enable = 0;</span>

<span class="sd">        &lt;INIT&gt; &#39;0b&#39; / [01]        :=&gt; BIN</span>
<span class="sd">        &lt;INIT&gt; &quot;0&quot;                :=&gt; OCT</span>
<span class="sd">        &lt;INIT&gt; &quot;&quot; / [1-9]         :=&gt; DEC</span>
<span class="sd">        &lt;INIT&gt; &#39;0x&#39; / [0-9a-fA-F] :=&gt; HEX</span>
<span class="sd">        &lt;INIT&gt; * { return None; }</span>

<span class="sd">        &lt;BIN&gt; [01]  { add(&amp;mut num, yyinput, yycursor, 48, 2);  continue &#39;lex; }</span>
<span class="sd">        &lt;OCT&gt; [0-7] { add(&amp;mut num, yyinput, yycursor, 48, 8);  continue &#39;lex; }</span>
<span class="sd">        &lt;DEC&gt; [0-9] { add(&amp;mut num, yyinput, yycursor, 48, 10); continue &#39;lex; }</span>
<span class="sd">        &lt;HEX&gt; [0-9] { add(&amp;mut num, yyinput, yycursor, 48, 16); continue &#39;lex; }</span>
<span class="sd">        &lt;HEX&gt; [a-f] { add(&amp;mut num, yyinput, yycursor, 87, 16); continue &#39;lex; }</span>
<span class="sd">        &lt;HEX&gt; [A-F] { add(&amp;mut num, yyinput, yycursor, 55, 16); continue &#39;lex; }</span>

<span class="sd">        &lt;BIN, OCT, DEC, HEX&gt; * {</span>
<span class="sd">            return if num &lt; ERROR { Some(num as u32) } else { None };</span>
<span class="sd">        }</span>
<span class="sd">    */</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">parse_u32</span><span class="p">(</span><span class="s">b&quot;</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">parse_u32</span><span class="p">(</span><span class="s">b&quot;1234567890</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">1234567890</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">parse_u32</span><span class="p">(</span><span class="s">b&quot;0b1101</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">13</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">parse_u32</span><span class="p">(</span><span class="s">b&quot;0x7Fe</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">2046</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">parse_u32</span><span class="p">(</span><span class="s">b&quot;0644</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">420</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">parse_u32</span><span class="p">(</span><span class="s">b&quot;9999999999</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="storable-state">
<h3>Storable state<a class="headerlink" href="#storable-state" title="Permalink to this headline">¶</a></h3>
<p>With <code class="docutils literal notranslate"><span class="pre">--storable-state</span></code> option re2rust generates a lexer that can store
its current state, return to the caller, and later resume operations exactly
where it left off. The default mode of operation in re2rust is a “pull” model,
in which the lexer “pulls” more input whenever it needs it. This may be
unacceptable in cases when the input becomes available piece by piece (for
example, if the lexer is invoked by the parser, or if the lexer program
communicates via a socket protocol with some other program that must wait for a
reply from the lexer before it transmits the next message). Storable state
feature is intended exactly for such cases: it allows one to generate lexers that
work in a “push” model. When the lexer needs more input, it stores its state and
returns to the caller. Later, when more input becomes available, the caller
resumes the lexer exactly where it stopped. There are a few changes necessary
compared to the “pull” model:</p>
<ul class="simple">
<li><p>Define <code class="docutils literal notranslate"><span class="pre">YYSETSTATE()</span></code> and <code class="docutils literal notranslate"><span class="pre">YYGETSTATE(state)</span></code> primitives.</p></li>
<li><p>Define <code class="docutils literal notranslate"><span class="pre">yych</span></code>, <code class="docutils literal notranslate"><span class="pre">yyaccept</span></code> (if used) and <code class="docutils literal notranslate"><span class="pre">state</span></code> variables as a part of
persistent lexer state. The <code class="docutils literal notranslate"><span class="pre">state</span></code> variable should be initialized to <code class="docutils literal notranslate"><span class="pre">-1</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> should return to the outer program instead of trying to supply more
input. Return code should indicate that lexer needs more input.</p></li>
<li><p>The outer program should recognize situations when lexer needs more input and
respond appropriately.</p></li>
<li><p>Optionally use <code class="docutils literal notranslate"><span class="pre">getstate</span></code> block to generate <code class="docutils literal notranslate"><span class="pre">YYGETSTATE</span></code> switch detached
from the main lexer. This only works for languages that have <code class="docutils literal notranslate"><span class="pre">goto</span></code> (not in
<code class="docutils literal notranslate"><span class="pre">--loop-switch</span></code> mode).</p></li>
<li><p>Use <code class="docutils literal notranslate"><span class="pre">re2c:eof</span></code> and the <a class="reference internal" href="#sentinel-with-bounds-checks">sentinel with bounds checks</a> method to handle the
end of input. Padding-based method may not work because it is unclear when to
append padding: the current end of input may not be the ultimate end of input,
and appending padding too early may cut off a partially read greedy lexeme.
Furthermore, due to high-level program logic getting more input may depend on
processing the lexeme at the end of buffer (which already is blocked due to
the end-of-input condition).</p></li>
</ul>
<p>Here is an example of a “push” model lexer that simulates reading packets from a
socket. The lexer loops until it encounters the end of input and returns to the
calling function. The calling function provides more input by “sending” the next
packet and resumes lexing. This process stops when all the packets have been
sent, or when there is an error.</p>
<p><a class="reference external" href="../../playground?example=rust/state/push.re"><img alt="run_state_push" class="feed" src="../_images/play.png" style="width: 2em;" /></a>   <a class="reference external" href="../../playground?example=rust/state/push.re">Run in playground</a></p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2rust $INPUT -o $OUTPUT -f</span>

<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="p">{</span><span class="n">Read</span><span class="p">,</span><span class="w"> </span><span class="n">Write</span><span class="p">};</span><span class="w"></span>

<span class="k">const</span><span class="w"> </span><span class="n">DEBUG</span>: <span class="kt">bool</span> <span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"></span>
<span class="fm">macro_rules!</span><span class="w"> </span><span class="n">log</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="cp">$($fmt</span>:<span class="nc">expr</span><span class="p">)</span><span class="o">?</span><span class="w"> </span><span class="cp">$(,</span><span class="w"> </span><span class="cp">$args</span>:<span class="nc">expr</span><span class="p">)</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">DEBUG</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="cp">$($fmt</span><span class="p">)</span><span class="o">?</span><span class="w"> </span><span class="cp">$(,</span><span class="w"> </span><span class="cp">$args</span><span class="p">)</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Use a small buffer to cover the case when a lexeme doesn&#39;t fit.</span>
<span class="c1">// In real world use a larger buffer.</span>
<span class="k">const</span><span class="w"> </span><span class="n">BUFSIZE</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">State</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">file</span>: <span class="nc">File</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">yyinput</span>: <span class="p">[</span><span class="kt">u8</span><span class="p">;</span><span class="w"> </span><span class="n">BUFSIZE</span><span class="p">],</span><span class="w"></span>
<span class="w">    </span><span class="n">yylimit</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">yycursor</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">yymarker</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">token</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">yystate</span>: <span class="kt">isize</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#[derive(Debug, PartialEq)]</span><span class="w"></span>
<span class="k">enum</span> <span class="nc">Status</span><span class="w"> </span><span class="p">{</span><span class="n">End</span><span class="p">,</span><span class="w"> </span><span class="n">Ready</span><span class="p">,</span><span class="w"> </span><span class="n">Waiting</span><span class="p">,</span><span class="w"> </span><span class="n">BadPacket</span><span class="p">,</span><span class="w"> </span><span class="n">BigPacket</span><span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">fill</span><span class="p">(</span><span class="n">st</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">State</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Status</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Error: lexeme too long. In real life can reallocate a larger buffer.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">st</span><span class="p">.</span><span class="n">token</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">Status</span>::<span class="n">BigPacket</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Shift buffer contents (discard everything up to the current lexeme).</span>
<span class="w">    </span><span class="n">st</span><span class="p">.</span><span class="n">yyinput</span><span class="p">.</span><span class="n">copy_within</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">token</span><span class="o">..</span><span class="n">st</span><span class="p">.</span><span class="n">yylimit</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">st</span><span class="p">.</span><span class="n">yylimit</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">st</span><span class="p">.</span><span class="n">token</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">st</span><span class="p">.</span><span class="n">yycursor</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">st</span><span class="p">.</span><span class="n">token</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">st</span><span class="p">.</span><span class="n">yymarker</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st</span><span class="p">.</span><span class="n">yymarker</span><span class="p">.</span><span class="n">overflowing_sub</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">token</span><span class="p">).</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// underflows if marker is unused</span>
<span class="w">    </span><span class="n">st</span><span class="p">.</span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Fill free space at the end of buffer with new data.</span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">st</span><span class="p">.</span><span class="n">file</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">st</span><span class="p">.</span><span class="n">yyinput</span><span class="p">[</span><span class="n">st</span><span class="p">.</span><span class="n">yylimit</span><span class="o">..</span><span class="n">BUFSIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// -1 for sentinel</span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">st</span><span class="p">.</span><span class="n">yylimit</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">st</span><span class="p">.</span><span class="n">yyinput</span><span class="p">[</span><span class="n">st</span><span class="p">.</span><span class="n">yylimit</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// append sentinel symbol</span>
<span class="w">        </span><span class="p">},</span><span class="w"></span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">why</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&quot;cannot read from file: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">why</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Status</span>::<span class="n">Ready</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">lex</span><span class="p">(</span><span class="n">yyrecord</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">State</span><span class="p">,</span><span class="w"> </span><span class="n">recv</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Status</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">yych</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="o">&#39;</span><span class="na">lex</span>: <span class="nc">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">yyrecord</span><span class="p">.</span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">yyrecord</span><span class="p">.</span><span class="n">yycursor</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="sd">/*!re2c</span>
<span class="sd">        re2c:api = record;</span>
<span class="sd">        re2c:eof = 0;</span>
<span class="sd">        re2c:YYCTYPE = &quot;u8&quot;;</span>
<span class="sd">        re2c:YYFILL = &quot;return Status::Waiting;&quot;;</span>

<span class="sd">        packet = [a-z]+[;];</span>

<span class="sd">        *      { return Status::BadPacket; }</span>
<span class="sd">        $      { return Status::End; }</span>
<span class="sd">        packet { *recv += 1; continue &#39;lex; }</span>
<span class="sd">    */</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">test</span><span class="p">(</span><span class="n">packets</span>: <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">expect</span>: <span class="nc">Status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Create a pipe (open the same file for reading and writing).</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">fname</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;pipe&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">fw</span>: <span class="nc">File</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">File</span>::<span class="n">create</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">why</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&quot;cannot open {}: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fname</span><span class="p">,</span><span class="w"> </span><span class="n">why</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">file</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">fr</span>: <span class="nc">File</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">why</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&quot;cannot read file {}: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fname</span><span class="p">,</span><span class="w"> </span><span class="n">why</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">file</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Initialize lexer state: `state` value is -1, all offsets are at the end</span>
<span class="w">    </span><span class="c1">// of buffer, the character at `yylimit` offset is the sentinel (null).</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">yylimit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BUFSIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">State</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">file</span>: <span class="nc">fr</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Sentinel (at `yylimit` offset) is set to null, which triggers YYFILL.</span>
<span class="w">        </span><span class="n">yyinput</span>: <span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">BUFSIZE</span><span class="p">],</span><span class="w"></span>
<span class="w">        </span><span class="n">yylimit</span>: <span class="nc">yylimit</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">yycursor</span>: <span class="nc">yylimit</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">yymarker</span>: <span class="nc">yylimit</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">token</span>: <span class="nc">yylimit</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">yystate</span>: <span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Main loop. The buffer contains incomplete data which appears packet by</span>
<span class="w">    </span><span class="c1">// packet. When the lexer needs more input it saves its internal state and</span>
<span class="w">    </span><span class="c1">// returns to the caller which should provide more input and resume lexing.</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">status</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">send</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">recv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lex</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">state</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">recv</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Status</span>::<span class="n">End</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">log</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;done: got {} packets&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">recv</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Status</span>::<span class="n">Waiting</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">log</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;waiting...&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">send</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">packets</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">log</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;sent packet {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">send</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="k">match</span><span class="w"> </span><span class="n">fw</span><span class="p">.</span><span class="n">write_all</span><span class="p">(</span><span class="n">packets</span><span class="p">[</span><span class="n">send</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="nb">Err</span><span class="p">(</span><span class="n">why</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&quot;cannot write to {}: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fname</span><span class="p">,</span><span class="w"> </span><span class="n">why</span><span class="p">),</span><span class="w"></span>
<span class="w">                    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">send</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fill</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">state</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">log</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;queue: &#39;{}&#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from_utf8_lossy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="p">.</span><span class="n">yyinput</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Status</span>::<span class="n">BigPacket</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">log</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;error: packet too big&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">status</span><span class="p">,</span><span class="w"> </span><span class="n">Status</span>::<span class="n">Ready</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">status</span><span class="p">,</span><span class="w"> </span><span class="n">Status</span>::<span class="n">BadPacket</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">log</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;error: ill-formed packet&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Check results.</span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">status</span><span class="p">,</span><span class="w"> </span><span class="n">expect</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Status</span>::<span class="n">End</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">recv</span><span class="p">,</span><span class="w"> </span><span class="n">send</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Cleanup: remove input file.</span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">remove_file</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">why</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&quot;cannot remove {}: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fname</span><span class="p">,</span><span class="w"> </span><span class="n">why</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">test</span><span class="p">(</span><span class="fm">vec!</span><span class="p">[],</span><span class="w"> </span><span class="n">Status</span>::<span class="n">End</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">test</span><span class="p">(</span><span class="fm">vec!</span><span class="p">[</span><span class="s">b&quot;zero;&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">b&quot;one;&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">b&quot;two;&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">b&quot;three;&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">b&quot;four;&quot;</span><span class="p">],</span><span class="w"> </span><span class="n">Status</span>::<span class="n">End</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">test</span><span class="p">(</span><span class="fm">vec!</span><span class="p">[</span><span class="s">b&quot;zer0;&quot;</span><span class="p">],</span><span class="w"> </span><span class="n">Status</span>::<span class="n">BadPacket</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">test</span><span class="p">(</span><span class="fm">vec!</span><span class="p">[</span><span class="s">b&quot;goooooooooogle;&quot;</span><span class="p">],</span><span class="w"> </span><span class="n">Status</span>::<span class="n">BigPacket</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="reusable-blocks">
<h3>Reusable blocks<a class="headerlink" href="#reusable-blocks" title="Permalink to this headline">¶</a></h3>
<p>Reusable blocks of the form <code class="docutils literal notranslate"><span class="pre">/*!rules:re2c[:&lt;name&gt;]</span> <span class="pre">...</span> <span class="pre">*/</span></code> or
<code class="docutils literal notranslate"><span class="pre">%{rules[:&lt;name&gt;]</span> <span class="pre">...</span> <span class="pre">%}</span></code> can be reused any number of times and combined with
other re2rust blocks. The <code class="docutils literal notranslate"><span class="pre">&lt;name&gt;</span></code> is optional. A rules block can be used in a
<code class="docutils literal notranslate"><span class="pre">use</span></code> block or directive. The code for a rules block is generated at every
point of use.</p>
<p>Use blocks are defined with <code class="docutils literal notranslate"><span class="pre">/*!use:re2c[:&lt;name&gt;]</span> <span class="pre">...</span> <span class="pre">*/</span></code> or
<code class="docutils literal notranslate"><span class="pre">%{use[:&lt;name&gt;]</span> <span class="pre">...</span> <span class="pre">%}</span></code>. The <code class="docutils literal notranslate"><span class="pre">&lt;name&gt;</span></code> is optional: if it’s not specified,
the associated rules block is the most recent one (whether named or unnamed).
A use block can add named definitions, configurations and rules of its own.
An important use case for use blocks is a lexer that supports multiple input
encodings: the same rules block is reused multiple times with encoding-specific
configurations (see the example below).</p>
<p>In-block use directive <code class="docutils literal notranslate"><span class="pre">!use:&lt;name&gt;;</span></code> can be used from inside of a re2rust
block. It merges the referenced block <code class="docutils literal notranslate"><span class="pre">&lt;name&gt;</span></code> into the current one. If some
of the merged rules and configurations overlap with the previously defined ones,
conflicts are resolved in the usual way: the earliest rule takes priority, and
latest configuration overrides preceding ones. One exception are the special
rules <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">$</span></code> and (in condition mode) <code class="docutils literal notranslate"><span class="pre">&lt;!&gt;</span></code>, for which a block-local
definition overrides any inherited ones. Use directive allows one to combine
different re2rust blocks together in one block (see the example below).</p>
<p>Named blocks and in-block use directive were added in re2rust version 2.2.
Since that version reusable blocks are allowed by default (no special option
is needed). Before version 2.2 reuse mode was enabled with <code class="docutils literal notranslate"><span class="pre">-r</span> <span class="pre">--reusable</span></code>
option. Before version 1.2 reusable blocks could not be mixed with normal
blocks.</p>
<p>Example of a <code class="docutils literal notranslate"><span class="pre">!use</span></code> directive:</p>
<p><a class="reference external" href="../../playground?example=rust/reuse/usedir.re"><img alt="run_reuse_usedir" class="feed" src="../_images/play.png" style="width: 2em;" /></a>   <a class="reference external" href="../../playground?example=rust/reuse/usedir.re">Run in playground</a></p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2rust $INPUT -o $OUTPUT --api simple</span>

<span class="c1">// This example shows how to combine reusable re2c blocks: two blocks</span>
<span class="c1">// (&#39;colors&#39; and &#39;fish&#39;) are merged into one. The &#39;salmon&#39; rule occurs</span>
<span class="c1">// in both blocks; the &#39;fish&#39; block takes priority because it is used</span>
<span class="c1">// earlier. Default rule * occurs in all three blocks; the local (not</span>
<span class="c1">// inherited) definition takes priority.</span>

<span class="cp">#[derive(Debug, PartialEq)]</span><span class="w"></span>
<span class="k">enum</span> <span class="nc">Ans</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Color</span><span class="p">,</span><span class="w"> </span><span class="n">Fish</span><span class="p">,</span><span class="w"> </span><span class="n">Dunno</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="sd">/*!rules:re2c:colors</span>
<span class="sd">    *                            { panic!(&quot;ah&quot;); }</span>
<span class="sd">    &quot;red&quot; | &quot;salmon&quot; | &quot;magenta&quot; { return Ans::Color; }</span>
<span class="sd">*/</span><span class="w"></span>

<span class="sd">/*!rules:re2c:fish</span>
<span class="sd">    *                            { panic!(&quot;oh&quot;); }</span>
<span class="sd">    &quot;haddock&quot; | &quot;salmon&quot; | &quot;eel&quot; { return Ans::Fish; }</span>
<span class="sd">*/</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">lex</span><span class="p">(</span><span class="n">yyinput</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">Ans</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span><span class="n">yyinput</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// expect nonempty input</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">yycursor</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">yymarker</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="sd">/*!re2c</span>
<span class="sd">        re2c:yyfill:enable = 0;</span>
<span class="sd">        re2c:YYCTYPE = u8;</span>

<span class="sd">        !use:fish;</span>
<span class="sd">        !use:colors;</span>
<span class="sd">        * { return Ans::Dunno; }  // overrides inherited &#39;*&#39; rules</span>
<span class="sd">    */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">b&quot;salmon&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">Ans</span>::<span class="n">Fish</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">b&quot;what?&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">Ans</span>::<span class="n">Dunno</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Example of a <code class="docutils literal notranslate"><span class="pre">/*!use:re2c</span> <span class="pre">...</span> <span class="pre">*/</span></code> block:</p>
<p><a class="reference external" href="../../playground?example=rust/reuse/reuse.re"><img alt="run_reuse_reuse" class="feed" src="../_images/play.png" style="width: 2em;" /></a>   <a class="reference external" href="../../playground?example=rust/reuse/reuse.re">Run in playground</a></p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2rust $INPUT -o $OUTPUT --input-encoding utf8 --api simple</span>

<span class="c1">// This example supports multiple input encodings: UTF-8 and UTF-32.</span>
<span class="c1">// Both lexers are generated from the same rules block, and the use</span>
<span class="c1">// blocks add only encoding-specific configurations.</span>
<span class="sd">/*!rules:re2c</span>
<span class="sd">    re2c:yyfill:enable = 0;</span>

<span class="sd">    &quot;∀x ∃y&quot; { return Some(yycursor); }</span>
<span class="sd">    *       { return None; }</span>
<span class="sd">*/</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">lex_utf8</span><span class="p">(</span><span class="n">yyinput</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span><span class="n">yyinput</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// expect nonempty input</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">yycursor</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">yymarker</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="sd">/*!use:re2c</span>
<span class="sd">        re2c:encoding:utf8 = 1;</span>
<span class="sd">        re2c:YYCTYPE = u8;</span>
<span class="sd">    */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">lex_utf32</span><span class="p">(</span><span class="n">yyinput</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u32</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span><span class="n">yyinput</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// expect nonempty input</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">yycursor</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">yymarker</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="sd">/*!use:re2c</span>
<span class="sd">        re2c:encoding:utf32 = 1;</span>
<span class="sd">        re2c:YYCTYPE = u32;</span>
<span class="sd">    */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mh">0xe2</span><span class="p">,</span><span class="w"> </span><span class="mh">0x88</span><span class="p">,</span><span class="w"> </span><span class="mh">0x80</span><span class="p">,</span><span class="w"> </span><span class="mh">0x78</span><span class="p">,</span><span class="w"> </span><span class="mh">0x20</span><span class="p">,</span><span class="w"> </span><span class="mh">0xe2</span><span class="p">,</span><span class="w"> </span><span class="mh">0x88</span><span class="p">,</span><span class="w"> </span><span class="mh">0x83</span><span class="p">,</span><span class="w"> </span><span class="mh">0x79</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">lex_utf8</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s8</span><span class="p">),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">s8</span><span class="p">.</span><span class="n">len</span><span class="p">()));</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mh">0x2200</span><span class="p">,</span><span class="w"> </span><span class="mh">0x78</span><span class="p">,</span><span class="w"> </span><span class="mh">0x20</span><span class="p">,</span><span class="w"> </span><span class="mh">0x2203</span><span class="p">,</span><span class="w"> </span><span class="mh">0x79</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">lex_utf32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s32</span><span class="p">),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">s32</span><span class="p">.</span><span class="n">len</span><span class="p">()));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="submatch-extraction">
<h3>Submatch extraction<a class="headerlink" href="#submatch-extraction" title="Permalink to this headline">¶</a></h3>
<p>re2rust has two options for submatch extraction.</p>
<dl class="simple">
<dt><strong>Tags</strong></dt><dd><p>The first option is to use standalone <em>tags</em> of the form <code class="docutils literal notranslate"><span class="pre">&#64;stag</span></code> or
<code class="docutils literal notranslate"><span class="pre">#mtag</span></code>, where <code class="docutils literal notranslate"><span class="pre">stag</span></code> and <code class="docutils literal notranslate"><span class="pre">mtag</span></code> are arbitrary used-defined names.
Tags are enabled with <code class="docutils literal notranslate"><span class="pre">-T</span> <span class="pre">--tags</span></code> option or <code class="docutils literal notranslate"><span class="pre">re2c:tags</span> <span class="pre">=</span> <span class="pre">1</span></code>
configuration. Semantically tags are position markers: they can be
inserted anywhere in a regular expression, and they bind to the
corresponding position (or multiple positions) in the input string.
<em>S-tags</em> bind to the last matching position, and <em>m-tags</em> bind to a list of
positions (they may be used in repetition subexpressions, where a single
position in a regular expression corresponds to multiple positions in the
input string). All tags should be defined by the user, either manually or
with the help of <code class="docutils literal notranslate"><span class="pre">svars</span></code> and <code class="docutils literal notranslate"><span class="pre">mvars</span></code> blocks. If there is more than one
way tags can be matched against the input, ambiguity is resolved using
leftmost greedy disambiguation strategy.</p>
</dd>
<dt><strong>Captures</strong></dt><dd><p>The second option is to use <em>capturing groups</em>. They are enabled with
<code class="docutils literal notranslate"><span class="pre">--captures</span></code> option or <code class="docutils literal notranslate"><span class="pre">re2c:captures</span> <span class="pre">=</span> <span class="pre">1</span></code> configuration. There are two
flavours for different disambiguation policies, <code class="docutils literal notranslate"><span class="pre">--leftmost-captures</span></code>
(the default) is for leftmost greedy policy, and, <code class="docutils literal notranslate"><span class="pre">--posix-captures</span></code> is
for POSIX longest-match policy. In this mode all parenthesized
subexpressions are considered capturing groups, and a bang can be used to
mark non-capturing groups: <code class="docutils literal notranslate"><span class="pre">(!</span> <span class="pre">...</span> <span class="pre">)</span></code>. With <code class="docutils literal notranslate"><span class="pre">--invert-captures</span></code> option or
<code class="docutils literal notranslate"><span class="pre">re2c:invert-captures</span> <span class="pre">=</span> <span class="pre">1</span></code> configuration the meaning of bang is inverted.
The number of groups for the matching rule is stored in a variable
<code class="docutils literal notranslate"><span class="pre">yynmatch</span></code> (the whole regular expression is group number zero), and
submatch results are stored in <code class="docutils literal notranslate"><span class="pre">yypmatch</span></code> array. Both <code class="docutils literal notranslate"><span class="pre">yynmatch</span></code> and
<code class="docutils literal notranslate"><span class="pre">yypmatch</span></code> should be defined by the user, and <code class="docutils literal notranslate"><span class="pre">yypmatch</span></code> size must be at
least <code class="docutils literal notranslate"><span class="pre">[yynmatch</span> <span class="pre">*</span> <span class="pre">2]</span></code>. Use <code class="docutils literal notranslate"><span class="pre">maxnmatch</span></code> block to  define <code class="docutils literal notranslate"><span class="pre">YYMAXNMATCH</span></code>,
a constant that equals to the maximum value of <code class="docutils literal notranslate"><span class="pre">yynmatch</span></code> among all rules.</p>
</dd>
<dt><strong>Captvars</strong></dt><dd><p>Another way to use capturing groups is the <code class="docutils literal notranslate"><span class="pre">--captvars</span></code> option or
<code class="docutils literal notranslate"><span class="pre">re2c:captvars</span> <span class="pre">=</span> <span class="pre">1</span></code> configuration. The only difference with <code class="docutils literal notranslate"><span class="pre">--captures</span></code>
is in the way the generated code stores submatch results: instead of
<code class="docutils literal notranslate"><span class="pre">yynmatch</span></code> and <code class="docutils literal notranslate"><span class="pre">yypmatch</span></code> re2rust generates variables <code class="docutils literal notranslate"><span class="pre">yytl&lt;k&gt;</span></code> and
<code class="docutils literal notranslate"><span class="pre">yytr&lt;k&gt;</span></code> for <em>k</em>-th capturing group (the user should declare these using
an <code class="docutils literal notranslate"><span class="pre">svars</span></code> block). Captures with variables support two disambiguation
policies: <code class="docutils literal notranslate"><span class="pre">--leftmost-captvars</span></code> or <code class="docutils literal notranslate"><span class="pre">re2c:leftmost-captvars</span> <span class="pre">=</span> <span class="pre">1</span></code> for
leftmost greedy policy (the default one) and <code class="docutils literal notranslate"><span class="pre">--posix-captvars</span></code> or
<code class="docutils literal notranslate"><span class="pre">re2c:posix-captvars</span></code> for POSIX longest-match policy.</p>
</dd>
</dl>
<p>Under the hood all these options translate into tags and
<a class="reference external" href="https://arxiv.org/abs/1907.08837">Tagged Deterministic Finite Automata with Lookahead</a>.
The core idea of TDFA is to minimize the overhead on submatch extraction.
In the extreme, if there’re no tags or captures in a regular expression, TDFA is
just an ordinary DFA. If the number of tags is moderate, the overhead is barely
noticeable. The generated TDFA uses a number of <em>tag variables</em> which do not map
directly to tags: a single variable may be used for different tags, and a tag
may require multiple variables to hold all its possible values. Eventually
ambiguity is resolved, and only one final variable per tag survives. Tag
variables should be defined using <code class="docutils literal notranslate"><span class="pre">stags</span></code> or <code class="docutils literal notranslate"><span class="pre">mtags</span></code> blocks. If lexer state
is stored, tag variables should be part of it. They also need to be updated  by
<code class="docutils literal notranslate"><span class="pre">YYFILL</span></code>.</p>
<p>S-tags support the following operations:</p>
<ul class="simple">
<li><p>save input position to an s-tag: <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">=</span> <span class="pre">YYCURSOR</span></code> with C pointer API or a
user-defined operation <code class="docutils literal notranslate"><span class="pre">YYSTAGP(t)</span></code> with generic API</p></li>
<li><p>save default value to an s-tag: <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">=</span> <span class="pre">NULL</span></code> with C pointer API or a
user-defined operation <code class="docutils literal notranslate"><span class="pre">YYSTAGN(t)</span></code> with generic API</p></li>
<li><p>copy one s-tag to another: <code class="docutils literal notranslate"><span class="pre">t1</span> <span class="pre">=</span> <span class="pre">t2</span></code></p></li>
</ul>
<p>M-tags support the following operations:</p>
<ul class="simple">
<li><p>append input position to an m-tag: a user-defined operation <code class="docutils literal notranslate"><span class="pre">YYMTAGP(t)</span></code>
with both default and generic API</p></li>
<li><p>append default value to an m-tag: a user-defined operation <code class="docutils literal notranslate"><span class="pre">YYMTAGN(t)</span></code>
with both default and generic API</p></li>
<li><p>copy one m-tag to another: <code class="docutils literal notranslate"><span class="pre">t1</span> <span class="pre">=</span> <span class="pre">t2</span></code></p></li>
</ul>
<p>S-tags can be implemented as scalar values (pointers or offsets). M-tags need a
more complex representation, as they need to store a sequence of tag values. The
most naive and inefficient representation of an m-tag is a list (array, vector)
of tag values; a more efficient representation is to store all m-tags in a
prefix-tree represented as array of nodes <code class="docutils literal notranslate"><span class="pre">(v,</span> <span class="pre">p)</span></code>, where <code class="docutils literal notranslate"><span class="pre">v</span></code> is tag value
and <code class="docutils literal notranslate"><span class="pre">p</span></code> is a pointer to parent node.</p>
<p>Here is a simple example of using s-tags to parse semantic versions consisting
of three numeric components: major, minor, patch (the latter is optional).
See below for a more complex example that uses <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code>.</p>
<p><a class="reference external" href="../../playground?example=rust/submatch/01_stags.re"><img alt="run_submatch_01" class="feed" src="../_images/play.png" style="width: 2em;" /></a>   <a class="reference external" href="../../playground?example=rust/submatch/01_stags.re">Run in playground</a></p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2rust $INPUT -o $OUTPUT --api simple</span>

<span class="cp">#[derive(Debug, PartialEq)]</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">SemVer</span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">);</span><span class="w"> </span><span class="c1">// version: (major, minor, patch)</span>

<span class="k">const</span><span class="w"> </span><span class="n">NONE</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="kt">usize</span>::<span class="n">MAX</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">s2n</span><span class="p">(</span><span class="kt">str</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"> </span><span class="c1">// convert a pre-parsed string to a number</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">*</span><span class="n">i</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">48</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">parse</span><span class="p">(</span><span class="n">yyinput</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">SemVer</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">yyinput</span><span class="p">.</span><span class="n">last</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">0</span><span class="p">));</span><span class="w"> </span><span class="c1">// expect null-terminated input</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">yycursor</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">yymarker</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Final tag variables available in semantic action.</span>
<span class="w">    </span><span class="sd">/*!svars:re2c format = &#39;#[allow(unused_mut)]\nlet mut @@;\n&#39;; */</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Intermediate tag variables used by the lexer (must be autogenerated).</span>
<span class="w">    </span><span class="sd">/*!stags:re2c format = &#39;let mut @@ = NONE;&#39;; */</span><span class="w"></span>

<span class="w">    </span><span class="sd">/*!re2c</span>
<span class="sd">        re2c:YYCTYPE = u8;</span>
<span class="sd">        re2c:yyfill:enable = 0;</span>
<span class="sd">        re2c:tags = 1;</span>

<span class="sd">        num = [0-9]+;</span>

<span class="sd">        @t1 num @t2 &quot;.&quot; @t3 num @t4 (&quot;.&quot; @t5 num)? [\x00] {</span>
<span class="sd">            let major = s2n(&amp;yyinput[t1..t2]);</span>
<span class="sd">            let minor = s2n(&amp;yyinput[t3..t4]);</span>
<span class="sd">            let patch = if t5 != NONE {s2n(&amp;yyinput[t5..yycursor - 1])} else {0};</span>
<span class="sd">            return Some(SemVer(major, minor, patch));</span>
<span class="sd">        }</span>
<span class="sd">        * { return None; }</span>
<span class="sd">    */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">parse</span><span class="p">(</span><span class="s">b&quot;23.34</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">SemVer</span><span class="p">(</span><span class="mi">23</span><span class="p">,</span><span class="w"> </span><span class="mi">34</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)));</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">parse</span><span class="p">(</span><span class="s">b&quot;1.2.99999</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">SemVer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">99999</span><span class="p">)));</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">parse</span><span class="p">(</span><span class="s">b&quot;1.a</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Here is a more complex example of using s-tags with <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> to parse a file
with newline-separated semantic versions. Tag variables are part of the lexer
state, and they are adjusted in <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> like other input positions.
Note that it is necessary for s-tags because their values are invalidated after
shifting buffer contents. It may not be necessary in a custom implementation
where tag variables store offsets relative to the start of the input string
rather than the buffer, which may be the case with m-tags.</p>
<p><a class="reference external" href="../../playground?example=rust/submatch/01_stags_fill.re"><img alt="run_submatch_01_fill" class="feed" src="../_images/play.png" style="width: 2em;" /></a>   <a class="reference external" href="../../playground?example=rust/submatch/01_stags_fill.re">Run in playground</a></p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2rust $INPUT -o $OUTPUT</span>

<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="p">{</span><span class="n">Read</span><span class="p">,</span><span class="w"> </span><span class="n">Write</span><span class="p">};</span><span class="w"></span>

<span class="k">const</span><span class="w"> </span><span class="n">BUFSIZE</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="mi">4096</span><span class="p">;</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">NONE</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="kt">usize</span>::<span class="n">MAX</span><span class="p">;</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">State</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">file</span>: <span class="nc">File</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">yyinput</span>: <span class="p">[</span><span class="kt">u8</span><span class="p">;</span><span class="w"> </span><span class="n">BUFSIZE</span><span class="p">],</span><span class="w"></span>
<span class="w">    </span><span class="n">yylimit</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">yycursor</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">yymarker</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">token</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Intermediate tag variables must be part of the lexer state passed to YYFILL.</span>
<span class="w">    </span><span class="c1">// They don&#39;t correspond to tags and should be autogenerated by re2c.</span>
<span class="w">    </span><span class="sd">/*!stags:re2c format = &quot;@@: usize,\n&quot;; */</span><span class="w"></span>
<span class="w">    </span><span class="n">eof</span>: <span class="kt">bool</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#[derive(PartialEq)]</span><span class="w"></span>
<span class="k">enum</span> <span class="nc">Fill</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">Ok</span><span class="p">,</span><span class="w"> </span><span class="n">Eof</span><span class="p">,</span><span class="w"> </span><span class="n">LongLexeme</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="cp">#[derive(Debug, PartialEq)]</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">SemVer</span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">);</span><span class="w"> </span><span class="c1">// version: (major, minor, patch)</span>

<span class="k">fn</span> <span class="nf">s2n</span><span class="p">(</span><span class="kt">str</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"> </span><span class="c1">// convert a pre-parsed string to a number</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">*</span><span class="n">i</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">48</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="fm">macro_rules!</span><span class="w"> </span><span class="n">shift</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// ignore overflow, marker and tags may not be set yet</span>
<span class="w">    </span><span class="p">(</span><span class="cp">$x</span>:<span class="nc">expr</span><span class="p">,</span><span class="w"> </span><span class="cp">$y</span>:<span class="nc">expr</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cp">$x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cp">$x</span><span class="p">.</span><span class="n">overflowing_sub</span><span class="p">(</span><span class="cp">$y</span><span class="p">).</span><span class="mi">0</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">fill</span><span class="p">(</span><span class="n">st</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">State</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Fill</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">st</span><span class="p">.</span><span class="n">eof</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">Fill</span>::<span class="n">Eof</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Error: lexeme too long. In real life could reallocate a larger buffer.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">st</span><span class="p">.</span><span class="n">token</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">Fill</span>::<span class="n">LongLexeme</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Shift buffer contents (discard everything up to the current token).</span>
<span class="w">    </span><span class="n">st</span><span class="p">.</span><span class="n">yyinput</span><span class="p">.</span><span class="n">copy_within</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">token</span><span class="o">..</span><span class="n">st</span><span class="p">.</span><span class="n">yylimit</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">st</span><span class="p">.</span><span class="n">yylimit</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">st</span><span class="p">.</span><span class="n">token</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">st</span><span class="p">.</span><span class="n">yycursor</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">st</span><span class="p">.</span><span class="n">token</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">shift</span><span class="o">!</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">yymarker</span><span class="p">,</span><span class="w"> </span><span class="n">st</span><span class="p">.</span><span class="n">token</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Tag variables need to be shifted like other input positions. The check</span>
<span class="w">    </span><span class="c1">// for NONE is only needed if some tags are nested inside of alternative or</span>
<span class="w">    </span><span class="c1">// repetition, so that they can have NONE value.</span>
<span class="w">    </span><span class="sd">/*!stags:re2c format = &quot;if st.@@ != NONE { shift!(st.@@, st.token); }\n&quot;; */</span><span class="w"></span>
<span class="w">    </span><span class="n">st</span><span class="p">.</span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Fill free space at the end of buffer with new data from file.</span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">st</span><span class="p">.</span><span class="n">file</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">st</span><span class="p">.</span><span class="n">yyinput</span><span class="p">[</span><span class="n">st</span><span class="p">.</span><span class="n">yylimit</span><span class="o">..</span><span class="n">BUFSIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">st</span><span class="p">.</span><span class="n">yylimit</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">st</span><span class="p">.</span><span class="n">eof</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">st</span><span class="p">.</span><span class="n">yyinput</span><span class="p">[</span><span class="n">st</span><span class="p">.</span><span class="n">yylimit</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">why</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&quot;cannot read from file: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">why</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Fill</span>::<span class="nb">Ok</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">parse</span><span class="p">(</span><span class="n">st</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">State</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Vec</span>::<span class="o">&lt;</span><span class="n">SemVer</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">vers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Final tag variables available in semantic action.</span>
<span class="w">    </span><span class="sd">/*!svars:re2c format = &#39;let mut @@;\n&#39;; */</span><span class="w"></span>

<span class="w">    </span><span class="o">&#39;</span><span class="na">parse</span>: <span class="nc">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">st</span><span class="p">.</span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st</span><span class="p">.</span><span class="n">yycursor</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="sd">/*!re2c</span>
<span class="sd">        re2c:api = record;</span>
<span class="sd">        re2c:eof = 0;</span>
<span class="sd">        re2c:tags = 1;</span>
<span class="sd">        re2c:yyrecord = st;</span>
<span class="sd">        re2c:YYCTYPE = u8;</span>
<span class="sd">        re2c:YYFILL = &quot;fill(st) == Fill::Ok&quot;;</span>

<span class="sd">        num = [0-9]+;</span>

<span class="sd">        num @t1 &quot;.&quot; @t2 num @t3 (&quot;.&quot; @t4 num)? [\n] {</span>
<span class="sd">            let major = s2n(&amp;st.yyinput[st.token..t1]);</span>
<span class="sd">            let minor = s2n(&amp;st.yyinput[t2..t3]);</span>
<span class="sd">            let patch = if t4 != NONE {s2n(&amp;st.yyinput[t4..st.yycursor - 1])} else {0};</span>
<span class="sd">            vers.push(SemVer(major, minor, patch));</span>
<span class="sd">            continue &#39;parse;</span>
<span class="sd">        }</span>
<span class="sd">        $ { return Some(vers); }</span>
<span class="sd">        * { return None; }</span>
<span class="sd">    */</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">fname</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;input&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">verstr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">b&quot;1.22.333</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">expect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">BUFSIZE</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="n">SemVer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">22</span><span class="p">,</span><span class="w"> </span><span class="mi">333</span><span class="p">)).</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Prepare input file (make sure it exceeds buffer size).</span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">File</span>::<span class="n">create</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">why</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&quot;cannot open {}: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fname</span><span class="p">,</span><span class="w"> </span><span class="n">why</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">file</span><span class="p">.</span><span class="n">write_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">verstr</span><span class="p">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">BUFSIZE</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">Err</span><span class="p">(</span><span class="n">why</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&quot;cannot write to {}: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fname</span><span class="p">,</span><span class="w"> </span><span class="n">why</span><span class="p">),</span><span class="w"></span>
<span class="w">            </span><span class="nb">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Reopen input file for reading.</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">why</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&quot;cannot read file {}: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fname</span><span class="p">,</span><span class="w"> </span><span class="n">why</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">file</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Initialize lexer state.</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">yylimit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BUFSIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">st</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">State</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">file</span>: <span class="nc">file</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">yyinput</span>: <span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">BUFSIZE</span><span class="p">],</span><span class="w"> </span><span class="c1">// sentinel is set to zero, which triggers YYFILL</span>
<span class="w">        </span><span class="n">yylimit</span>: <span class="nc">yylimit</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">yycursor</span>: <span class="nc">yylimit</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">yymarker</span>: <span class="nc">yylimit</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">token</span>: <span class="nc">yylimit</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="sd">/*!stags:re2c format = &quot;@@: NONE,\n&quot;; */</span><span class="w"></span>
<span class="w">        </span><span class="n">eof</span>: <span class="nc">false</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Run the lexer and check results.</span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">parse</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">st</span><span class="p">),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">expect</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Cleanup: remove input file.</span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">remove_file</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">why</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&quot;cannot remove {}: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fname</span><span class="p">,</span><span class="w"> </span><span class="n">why</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Here is an example of using capturing groups to parse semantic versions.</p>
<p><a class="reference external" href="../../playground?example=rust/submatch/03_captures.re"><img alt="run_submatch_03" class="feed" src="../_images/play.png" style="width: 2em;" /></a>   <a class="reference external" href="../../playground?example=rust/submatch/03_captures.re">Run in playground</a></p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2rust $INPUT -o $OUTPUT --api simple</span>

<span class="cp">#[derive(Debug, PartialEq)]</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">SemVer</span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">);</span><span class="w"> </span><span class="c1">// version: (major, minor, patch)</span>

<span class="k">const</span><span class="w"> </span><span class="n">NONE</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="kt">usize</span>::<span class="n">MAX</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">s2n</span><span class="p">(</span><span class="kt">str</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"> </span><span class="c1">// convert a pre-parsed string to a number</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">*</span><span class="n">i</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">48</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">parse</span><span class="p">(</span><span class="n">yyinput</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">SemVer</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">yyinput</span><span class="p">.</span><span class="n">last</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">0</span><span class="p">));</span><span class="w"> </span><span class="c1">// expect null-terminated input</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">yycursor</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">yymarker</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Final tag variables available in semantic action.</span>
<span class="w">    </span><span class="sd">/*!stags:re2c format = &#39;let mut @@ = NONE;&#39;; */</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Intermediate tag variables used by the lexer (must be autogenerated).</span>
<span class="w">    </span><span class="sd">/*!svars:re2c format = &#39;#[allow(unused_mut)]\nlet mut @@;\n&#39;; */</span><span class="w"></span>

<span class="w">    </span><span class="sd">/*!re2c</span>
<span class="sd">        re2c:YYCTYPE = u8;</span>
<span class="sd">        re2c:yyfill:enable = 0;</span>
<span class="sd">        re2c:captvars = 1;</span>

<span class="sd">        num = [0-9]+;</span>

<span class="sd">        (num) &quot;.&quot; (num) (&quot;.&quot; num)? [\x00] {</span>
<span class="sd">            assert!(yytl0 == 0 &amp;&amp; yytr0 == yyinput.len());</span>
<span class="sd">            let major = s2n(&amp;yyinput[yytl1..yytr1]);</span>
<span class="sd">            let minor = s2n(&amp;yyinput[yytl2..yytr2]);</span>
<span class="sd">            let patch = if yytl3 == NONE {0} else {s2n(&amp;yyinput[yytl3 + 1..yytr3])};</span>
<span class="sd">            return Some(SemVer(major, minor, patch));</span>
<span class="sd">        }</span>
<span class="sd">        * { return None; }</span>
<span class="sd">    */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">parse</span><span class="p">(</span><span class="s">b&quot;23.34</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">SemVer</span><span class="p">(</span><span class="mi">23</span><span class="p">,</span><span class="w"> </span><span class="mi">34</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)));</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">parse</span><span class="p">(</span><span class="s">b&quot;1.2.99999</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">SemVer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">99999</span><span class="p">)));</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">parse</span><span class="p">(</span><span class="s">b&quot;1.a</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Here is an example of using m-tags to parse a version with a variable number of
components. Tag variables are stored in a trie.</p>
<p><a class="reference external" href="../../playground?example=rust/submatch/02_mtags.re"><img alt="run_submatch_02" class="feed" src="../_images/play.png" style="width: 2em;" /></a>   <a class="reference external" href="../../playground?example=rust/submatch/02_mtags.re">Run in playground</a></p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2rust $INPUT -o $OUTPUT --api simple</span>

<span class="k">const</span><span class="w"> </span><span class="n">NONE</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="kt">usize</span>::<span class="n">MAX</span><span class="p">;</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">MTAG_ROOT</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="n">NONE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="c1">// An m-tag tree is a way to store histories with an O(1) copy operation.</span>
<span class="c1">// Histories naturally form a tree, as they have common start and fork at some</span>
<span class="c1">// point. The tree is stored as an array of pairs (tag value, link to parent).</span>
<span class="c1">// An m-tag is represented with a single link in the tree (array index).</span>
<span class="k">type</span> <span class="nc">MtagTrie</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="o">&lt;</span><span class="n">MtagElem</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">MtagElem</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">elem</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="c1">// tag value</span>
<span class="w">    </span><span class="n">pred</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="c1">// index of the predecessor node or root</span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Append a single value to an m-tag history.</span>
<span class="k">fn</span> <span class="nf">add_mtag</span><span class="p">(</span><span class="n">trie</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">MtagTrie</span><span class="p">,</span><span class="w"> </span><span class="n">mtag</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">value</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">trie</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">MtagElem</span><span class="p">{</span><span class="n">elem</span>: <span class="nc">value</span><span class="p">,</span><span class="w"> </span><span class="n">pred</span>: <span class="nc">mtag</span><span class="p">});</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">trie</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Recursively unwind tag histories and collect version components.</span>
<span class="k">fn</span> <span class="nf">unwind</span><span class="p">(</span><span class="n">trie</span>: <span class="kp">&amp;</span><span class="nc">MtagTrie</span><span class="p">,</span><span class="w"> </span><span class="n">x</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="kt">str</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">],</span><span class="w"> </span><span class="n">ver</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Ver</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Reached the root of the m-tag tree, stop recursion.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MTAG_ROOT</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MTAG_ROOT</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Unwind history further.</span>
<span class="w">    </span><span class="n">unwind</span><span class="p">(</span><span class="n">trie</span><span class="p">,</span><span class="w"> </span><span class="n">trie</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">pred</span><span class="p">,</span><span class="w"> </span><span class="n">trie</span><span class="p">[</span><span class="n">y</span><span class="p">].</span><span class="n">pred</span><span class="p">,</span><span class="w"> </span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">ver</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Get tag values. Tag histories must have equal length.</span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">MTAG_ROOT</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">MTAG_ROOT</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">ex</span><span class="p">,</span><span class="w"> </span><span class="n">ey</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">trie</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">elem</span><span class="p">,</span><span class="w"> </span><span class="n">trie</span><span class="p">[</span><span class="n">y</span><span class="p">].</span><span class="n">elem</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">ex</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">NONE</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ey</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">NONE</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Both tags are valid string indices, extract component.</span>
<span class="w">        </span><span class="n">ver</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">s2n</span><span class="p">(</span><span class="o">&amp;</span><span class="kt">str</span><span class="p">[</span><span class="n">ex</span><span class="o">..</span><span class="n">ey</span><span class="p">]));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Both tags are NONE (this corresponds to zero repetitions).</span>
<span class="w">        </span><span class="fm">assert!</span><span class="p">(</span><span class="n">ex</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">NONE</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ey</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">NONE</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">type</span> <span class="nc">Ver</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="c1">// unbounded number of version components</span>

<span class="k">fn</span> <span class="nf">s2n</span><span class="p">(</span><span class="kt">str</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"> </span><span class="c1">// convert a pre-parsed string to a number</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">*</span><span class="n">i</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">48</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">parse</span><span class="p">(</span><span class="n">yyinput</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Ver</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">yyinput</span><span class="p">.</span><span class="n">last</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">0</span><span class="p">));</span><span class="w"> </span><span class="c1">// expect null-terminated input</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">yycursor</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">yymarker</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">mt</span>: <span class="nc">MtagTrie</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Final tag variables available in semantic action.</span>
<span class="w">    </span><span class="sd">/*!svars:re2c format = &#39;let @@;\n&#39;; */</span><span class="w"></span>
<span class="w">    </span><span class="sd">/*!mvars:re2c format = &#39;let @@;\n&#39;; */</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Intermediate tag variables used by the lexer (must be autogenerated).</span>
<span class="w">    </span><span class="sd">/*!stags:re2c format = &#39;let mut @@ = NONE;&#39;; */</span><span class="w"></span>
<span class="w">    </span><span class="sd">/*!mtags:re2c format = &#39;let mut @@ = MTAG_ROOT;&#39;; */</span><span class="w"></span>

<span class="w">    </span><span class="sd">/*!re2c</span>
<span class="sd">        re2c:YYCTYPE = u8;</span>
<span class="sd">        re2c:YYMTAGP = &quot;@@ = add_mtag(&amp;mut mt, @@, yycursor);&quot;;</span>
<span class="sd">        re2c:YYMTAGN = &quot;@@ = add_mtag(&amp;mut mt, @@, NONE);&quot;;</span>
<span class="sd">        re2c:yyfill:enable = 0;</span>
<span class="sd">        re2c:tags = 1;</span>

<span class="sd">        num = [0-9]+;</span>

<span class="sd">        @t1 num @t2 (&quot;.&quot; #t3 num #t4)* [\x00] {</span>
<span class="sd">            let mut ver: Ver = Vec::new();</span>
<span class="sd">            ver.push(s2n(&amp;yyinput[t1..t2]));</span>
<span class="sd">            unwind(&amp;mt, t3, t4, yyinput, &amp;mut ver);</span>
<span class="sd">            return Some(ver);</span>
<span class="sd">        }</span>
<span class="sd">        * { return None; }</span>
<span class="sd">    */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">parse</span><span class="p">(</span><span class="s">b&quot;1</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">parse</span><span class="p">(</span><span class="s">b&quot;1.2.3.4.5.6.7</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">]));</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">parse</span><span class="p">(</span><span class="s">b&quot;1.2.</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="encoding-support">
<h3>Encoding support<a class="headerlink" href="#encoding-support" title="Permalink to this headline">¶</a></h3>
<p>It is necessary to understand the difference between <strong>code points</strong> and
<strong>code units</strong>. A code point is a numeric identifier of a symbol. A code unit is
the smallest unit of storage in the encoded text. A single code point may be
represented with one or more code units. In a fixed-length encoding all code
points are represented with the same number of code units. In a variable-length
encoding code points may be represented with a different number of code units.
Note that the “any” rule <code class="docutils literal notranslate"><span class="pre">[^]</span></code> matches any code point, but not necessarily
any code unit (the only way to match any code unit regardless of the encoding
is the default rule <code class="docutils literal notranslate"><span class="pre">*</span></code>).
The generated lexer works with a stream of code units: <code class="docutils literal notranslate"><span class="pre">yych</span></code> stores a code
unit, and <code class="docutils literal notranslate"><span class="pre">YYCTYPE</span></code> is the code unit type. Regular expressions, on the other
hand, are specified in terms of code points. When re2rust compiles regular
expressions to automata it translates code points to code units. This is
generally not a simple mapping: in variable-length encodings a single code point
range may get translated to a complex code unit graph.
The following encodings are supported:</p>
<ul class="simple">
<li><p><strong>ASCII</strong> (enabled by default). It is a fixed-length encoding with code space
<code class="docutils literal notranslate"><span class="pre">[0-255]</span></code> and 1-byte code points and code units.</p></li>
<li><p><strong>EBCDIC</strong> (enabled with <code class="docutils literal notranslate"><span class="pre">--ebcdic</span></code> or <code class="docutils literal notranslate"><span class="pre">re2c:encoding:ebcdic</span></code>). It is a
fixed-length encoding with code space <code class="docutils literal notranslate"><span class="pre">[0-255]</span></code> and 1-byte code points and
code units.</p></li>
<li><p><strong>UCS2</strong> (enabled with <code class="docutils literal notranslate"><span class="pre">--ucs2</span></code> or <code class="docutils literal notranslate"><span class="pre">re2c:encoding:ucs2</span></code>). It is a
fixed-length encoding with code space <code class="docutils literal notranslate"><span class="pre">[0-0xFFFF]</span></code> and 2-byte code points
and code units.</p></li>
<li><p><strong>UTF8</strong> (enabled with <code class="docutils literal notranslate"><span class="pre">--utf8</span></code> or <code class="docutils literal notranslate"><span class="pre">re2c:encoding:utf8</span></code>). It is a
variable-length Unicode encoding. Code unit size is 1 byte. Code points are
represented with 1 – 4 code units.</p></li>
<li><p><strong>UTF16</strong> (enabled with <code class="docutils literal notranslate"><span class="pre">--utf16</span></code> or <code class="docutils literal notranslate"><span class="pre">re2c:encoding:utf16</span></code>). It is a
variable-length Unicode encoding. Code unit size is 2 bytes. Code points are
represented with 1 – 2 code units.</p></li>
<li><p><strong>UTF32</strong> (enabled with <code class="docutils literal notranslate"><span class="pre">--utf32</span></code> or <code class="docutils literal notranslate"><span class="pre">re2c:encoding:utf32</span></code>). It is a
fixed-length Unicode encoding with code space <code class="docutils literal notranslate"><span class="pre">[0-0x10FFFF]</span></code> and 4-byte code
points and code units.</p></li>
</ul>
<p>Include file <code class="docutils literal notranslate"><span class="pre">include/unicode_categories.re</span></code> provides re2rust definitions for the
standard Unicode categories.</p>
<p>Option <code class="docutils literal notranslate"><span class="pre">--input-encoding</span></code> specifies source file encoding, which can be used to
enable Unicode literals in regular expressions. For example
<code class="docutils literal notranslate"><span class="pre">--input-encoding</span> <span class="pre">utf8</span></code> tells re2rust that the source file is in UTF8 (it differs
from <code class="docutils literal notranslate"><span class="pre">--utf8</span></code> which sets input text encoding). Option <code class="docutils literal notranslate"><span class="pre">--encoding-policy</span></code>
specifies the way re2rust handles Unicode surrogates (code points in range
<code class="docutils literal notranslate"><span class="pre">[0xD800-0xDFFF]</span></code>).</p>
<p>Below is an example of a lexer for UTF8 encoded Unicode identifiers.</p>
<p><a class="reference external" href="../../playground?example=rust/encodings/unicode_identifier.re"><img alt="run_encodings" class="feed" src="../_images/play.png" style="width: 2em;" /></a>   <a class="reference external" href="../../playground?example=rust/encodings/unicode_identifier.re">Run in playground</a></p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2rust $INPUT -o $OUTPUT --utf8 --api simple</span>

<span class="sd">/*!include:re2c &quot;unicode_categories.re&quot; */</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">lex</span><span class="p">(</span><span class="n">yyinput</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">yyinput</span><span class="p">.</span><span class="n">last</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">0</span><span class="p">));</span><span class="w"> </span><span class="c1">// expect null-terminated input</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">yycursor</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">yymarker</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="sd">/*!re2c</span>
<span class="sd">        re2c:YYCTYPE = u8;</span>
<span class="sd">        re2c:yyfill:enable = 0;</span>

<span class="sd">        // Simplified &quot;Unicode Identifier and Pattern Syntax&quot;</span>
<span class="sd">        // (see https://unicode.org/reports/tr31)</span>
<span class="sd">        id_start    = L | Nl | [$_];</span>
<span class="sd">        id_continue = id_start | Mn | Mc | Nd | Pc | [\u200D\u05F3];</span>
<span class="sd">        identifier  = id_start id_continue*;</span>

<span class="sd">        identifier { return true; }</span>
<span class="sd">        *          { return false; }</span>
<span class="sd">    */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">&quot;_Ыдентификатор</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">.</span><span class="n">as_bytes</span><span class="p">()));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="include-files">
<h3>Include files<a class="headerlink" href="#include-files" title="Permalink to this headline">¶</a></h3>
<p>re2rust allows one to include other files using a block of the form
<code class="docutils literal notranslate"><span class="pre">/*!include:re2c</span> <span class="pre">FILE</span> <span class="pre">*/</span></code> or <code class="docutils literal notranslate"><span class="pre">%{include</span> <span class="pre">FILE</span> <span class="pre">%}</span></code>, or an in-block directive
<code class="docutils literal notranslate"><span class="pre">!include</span> <span class="pre">FILE</span> <span class="pre">;</span></code>, where <code class="docutils literal notranslate"><span class="pre">FILE</span></code> is a path to the file to be included.
re2rust looks for include files in the directory of the including file and in
include locations, which can be specified with the <code class="docutils literal notranslate"><span class="pre">-I</span></code> option. Include
blocks/directives in re2rust work in the same way as C/C++ <code class="docutils literal notranslate"><span class="pre">#include</span></code>: <code class="docutils literal notranslate"><span class="pre">FILE</span></code>
contents are copy-pasted verbatim in place of the block/directive. Include files
may have further includes of their own. Use <code class="docutils literal notranslate"><span class="pre">--depfile</span></code> option to track build
dependencies of the output file on include files.
re2rust provides some predefined include files that can be found in the
<code class="docutils literal notranslate"><span class="pre">include/</span></code> subdirectory of the project. These files contain definitions that
may be useful to other projects (such as Unicode categories) and form something
like a standard library for re2rust. Below is an example of using include files.</p>
<p>Include file 1 (definitions.rs):</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="cp">#[derive(Debug, PartialEq)]</span><span class="w"></span>
<span class="k">enum</span> <span class="nc">Num</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Int</span><span class="p">,</span><span class="w"> </span><span class="n">Float</span><span class="p">,</span><span class="w"> </span><span class="n">NaN</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="sd">/*!re2c</span>
<span class="sd">    number = [1-9][0-9]*;</span>
<span class="sd">*/</span><span class="w"></span>
</pre></div>
</div>
<p>Include file 2 (extra_rules.re.inc):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// floating-point numbers
frac  = [0-9]* &quot;.&quot; [0-9]+ | [0-9]+ &quot;.&quot;;
exp   = &#39;e&#39; [+-]? [0-9]+;
float = frac exp? | [0-9]+ exp;

float { return Num::Float; }
</pre></div>
</div>
<p>Input file:</p>
<p><a class="reference external" href="../../playground?example=rust/includes/include.re"><img alt="run_includes" class="feed" src="../_images/play.png" style="width: 2em;" /></a>   <a class="reference external" href="../../playground?example=rust/includes/include.re">Run in playground</a></p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2rust $INPUT -o $OUTPUT --api simple</span>

<span class="sd">/*!include:re2c &quot;definitions.rs&quot; */</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">lex</span><span class="p">(</span><span class="n">yyinput</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">Num</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">yyinput</span><span class="p">.</span><span class="n">last</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">0</span><span class="p">));</span><span class="w"> </span><span class="c1">// expect null-terminated input</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">yycursor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">yymarker</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="sd">/*!re2c</span>
<span class="sd">        re2c:yyfill:enable = 0;</span>
<span class="sd">        re2c:YYCTYPE = u8;</span>

<span class="sd">        *      { return Num::NaN; }</span>
<span class="sd">        number { return Num::Int; }</span>
<span class="sd">        !include &quot;extra_rules.re.inc&quot;;</span>
<span class="sd">    */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">b&quot;123</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">Num</span>::<span class="n">Int</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">b&quot;123.4567</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">Num</span>::<span class="n">Float</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="header-files">
<h3>Header files<a class="headerlink" href="#header-files" title="Permalink to this headline">¶</a></h3>
<p>re2rust allows one to generate header file from the input <code class="docutils literal notranslate"><span class="pre">.re</span></code> file using
<code class="docutils literal notranslate"><span class="pre">--header</span></code> option or <code class="docutils literal notranslate"><span class="pre">re2c:header</span></code> configuration and block pairs of the form
<code class="docutils literal notranslate"><span class="pre">/*!header:re2c:on*/</span></code> and <code class="docutils literal notranslate"><span class="pre">/*!header:re2c:off*/</span></code>, or <code class="docutils literal notranslate"><span class="pre">%{header:on%}</span></code> and
<code class="docutils literal notranslate"><span class="pre">%{header:off%}</span></code>. The first block marks the beginning of header file, and the
second block marks the end of it. Everything between these blocks is processed by
re2rust, and the generated code is written to the file specified with <code class="docutils literal notranslate"><span class="pre">--header</span></code>
option or <code class="docutils literal notranslate"><span class="pre">re2c:header</span></code> configuration (or <code class="docutils literal notranslate"><span class="pre">stdout</span></code> if neither option nor
configuration is used). Autogenerated header file may be needed in cases when
re2rust is used to generate definitions  that must be visible from other
translation units.</p>
<p>Here is an example of generating a header file that contains definition of the
lexer state with tag variables (the number variables depends on the regular
grammar and is unknown to the programmer).</p>
<p><a class="reference external" href="../../playground?example=rust/headers/header.re"><img alt="run_headers" class="feed" src="../_images/play.png" style="width: 2em;" /></a>   <a class="reference external" href="../../playground?example=rust/headers/header.re">Run in playground</a></p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2rust $INPUT -o $OUTPUT --header lexer/state.rs</span>

<span class="k">mod</span> <span class="nn">lexer</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">lexer</span>::<span class="n">state</span>::<span class="n">State</span><span class="p">;</span><span class="w"> </span><span class="c1">// the module is generated by re2c</span>

<span class="sd">/*!header:re2c:on*/</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">State</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">yyinput</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="p">[</span><span class="kt">u8</span><span class="p">],</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">yycursor</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="sd">/*!stags:re2c format = &quot;pub @@: usize,&quot;; */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="sd">/*!header:re2c:off*/</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">lex</span><span class="p">(</span><span class="n">yyrecord</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">State</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">yyrecord</span><span class="p">.</span><span class="n">yyinput</span><span class="p">.</span><span class="n">last</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">0</span><span class="p">));</span><span class="w"> </span><span class="c1">// expect null-terminated input</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span>: <span class="kt">usize</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="sd">/*!re2c</span>
<span class="sd">        re2c:header = &quot;lexer/state.rs&quot;;</span>
<span class="sd">        re2c:yyfill:enable = 0;</span>
<span class="sd">        re2c:api = record;</span>
<span class="sd">        re2c:YYCTYPE = &quot;u8&quot;;</span>
<span class="sd">        re2c:tags = 1;</span>

<span class="sd">        [a]* @t [b]* { return t; }</span>
<span class="sd">    */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">st</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">State</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">yyinput</span>: <span class="nc">b</span><span class="s">&quot;ab</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">yycursor</span>: <span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="sd">/*!stags:re2c format = &quot;@@: 0,&quot;; */</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">st</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The generated header file:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Generated by re2c */</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">State</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">yyinput</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="p">[</span><span class="kt">u8</span><span class="p">],</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">yycursor</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">yyt1</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="skeleton-programs">
<h3>Skeleton programs<a class="headerlink" href="#skeleton-programs" title="Permalink to this headline">¶</a></h3>
<p>With the <code class="docutils literal notranslate"><span class="pre">-S,</span> <span class="pre">--skeleton</span></code> option, re2rust ignores all non-re2rust code and
generates a self-contained C program that can be further compiled and executed.
The program consists of lexer code and input data. For each constructed DFA
(block or condition) re2rust generates a standalone lexer and two files: an
<code class="docutils literal notranslate"><span class="pre">.input</span></code> file with strings derived from the DFA and a <code class="docutils literal notranslate"><span class="pre">.keys</span></code> file with
expected match results. The program runs each lexer on the corresponding
<code class="docutils literal notranslate"><span class="pre">.input</span></code> file and compares results with the expectations.
Skeleton programs are very useful for a number of reasons:</p>
<ul class="simple">
<li><p>They can check correctness of various re2rust optimizations (the data is
generated early in the process, before any DFA transformations have taken
place).</p></li>
<li><p>Generating a set of input data with good coverage may be useful for both
testing and benchmarking.</p></li>
<li><p>Generating self-contained executable programs allows one to get minimized test
cases (the original code may be large or have a lot of dependencies).</p></li>
</ul>
<p>The difficulty with generating input data is that for all but the most trivial
cases the number of possible input strings is too large (even if the string
length is limited). re2rust solves this difficulty by generating sufficiently
many strings to cover almost all DFA transitions. It uses the following
algorithm. First, it constructs a skeleton of the DFA. For encodings with 1-byte
code unit size (such as ASCII, UTF-8 and EBCDIC) skeleton is just an exact copy
of the original DFA. For encodings with multibyte code units skeleton is a copy
of DFA with certain transitions omitted: namely, re2rust takes at most 256 code
units for each disjoint continuous range that corresponds to a DFA transition.
The chosen values are evenly distributed and include range bounds. Instead of
trying to cover all possible paths in the skeleton (which is infeasible) re2rust
generates sufficiently many paths to cover all skeleton transitions, and thus
trigger the corresponding conditional jumps in the lexer.
The algorithm implementation is limited by ~1Gb of transitions and consumes
constant amount of memory (re2rust writes data to file as soon as it is
generated).</p>
<p>Here is an example of a very simple program
<a class="reference download internal" download="" href="../_downloads/b26d681f6b14172f1891d366372e6766/example.re.txt"><code class="xref download docutils literal notranslate"><span class="pre">[example.re]</span></code></a>
that tries to match two-digit hexadecimal numbers:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*!re2c</span>
<span class="cm">    *              {}</span>
<span class="cm">    [0-9a-fA-F]{2} {}</span>
<span class="cm">*/</span><span class="w"></span>
</pre></div>
</div>
<p>We can see the generated DFA using <code class="docutils literal notranslate"><span class="pre">`re2c</span> <span class="pre">-D</span> <span class="pre">example.re</span> <span class="pre">|</span> <span class="pre">dot</span> <span class="pre">-Grankdir=LR</span> <span class="pre">-Tpng</span> <span class="pre">-o</span> <span class="pre">example.png`</span></code>:</p>
<a class="reference internal image-reference" href="../_images/example.png"><img alt="../_images/example.png" src="../_images/example.png" style="width: 60%;" /></a>
<p>Given this program, <code class="docutils literal notranslate"><span class="pre">`re2c</span> <span class="pre">-S</span> <span class="pre">-o</span> <span class="pre">example.c</span> <span class="pre">example.re`</span></code> generates three files:
<code class="docutils literal notranslate"><span class="pre">example.c</span></code> (main program), <code class="docutils literal notranslate"><span class="pre">example.c.line4.input</span></code> (input data) and <code class="docutils literal notranslate"><span class="pre">example.c.line4.keys</span></code> (expected match results).
First, let’s look at the generated strings
<a class="reference download internal" download="" href="../_downloads/ec08dc1741973b1ce49f0aec7c814767/example.c.line4.input"><code class="xref download docutils literal notranslate"><span class="pre">[example.c.line4.input]</span></code></a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ hexdump -v -e &#39;&quot;%08_ax &quot; 24/1 &quot;%02x &quot;&#39; -e &#39;&quot; |&quot; 24/1 &quot;%_p&quot; &quot;|\n&quot;&#39; example.c.line4.input
00000000 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 |........................|
00000018 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f |........ !&quot;#$%&amp;&#39;()*+,-./|
00000030 3a 3b 3c 3d 3e 3f 40 47 48 49 4a 4b 4c 4d 4e 4f 50 51 52 53 54 55 56 57 |:;&lt;=&gt;?@GHIJKLMNOPQRSTUVW|
[ ... ]
</pre></div>
</div>
<p>Byte sequences correspond to the paths in DFA.
All strings are glued together, so it’s hard to tell where is the end of one string and the beginning of another.
For that re2c generates keys <a class="reference download internal" download="" href="../_downloads/6c5dcbb14ecbca143bf25752d4329520/example.c.line4.keys"><code class="xref download docutils literal notranslate"><span class="pre">[example.c.line4.keys]</span></code></a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$hexdump -v -e &#39;&quot;%08_ax &quot; 36/1 &quot;%02x &quot; &quot;\n&quot;&#39; example.c.line4.keys
00000000 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe
00000024 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe
00000048 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe
[ ... ]
</pre></div>
</div>
<p>A key is a triplet: string length, the length of matching prefix and the number of matching rule.
(If tags are used, there is an additional key per each tag variable).
Keys are packed into an array.
In our case each key fits into 1 byte, but in case of a larger DFA they might take 2 or 4 bytes.
The generated program <a class="reference download internal" download="" href="../_downloads/5d457c87e75a5d09850980c4c6fc5d21/example.c.txt"><code class="xref download docutils literal notranslate"><span class="pre">[example.c]</span></code></a>
contains two auxilary functions: <code class="docutils literal notranslate"><span class="pre">read_file</span></code> and <code class="docutils literal notranslate"><span class="pre">action_line4</span></code>.
<code class="docutils literal notranslate"><span class="pre">read_file</span></code> is used to map <code class="docutils literal notranslate"><span class="pre">.input</span></code> and <code class="docutils literal notranslate"><span class="pre">.keys</span></code> files into memory (this function is shared between all lexers).
<code class="docutils literal notranslate"><span class="pre">action_line4</span></code> is a replacement for actions: it compares actual lexing results with the expected results.
This function is specific to each lexer.
Lexing is done by <code class="docutils literal notranslate"><span class="pre">lex_line4</span></code>: this function contains the generated DFA.
The skeleton program is self-contained, so we can compile and run it:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ cc -o example example.c
$ ./example
$ echo $?
0
</pre></div>
</div>
<p>When everything is fine (there are no errors) the program outputs nothing and
exits with zero. For the sake of example, let’s pretend that re2c has an error
that results in a missing <code class="docutils literal notranslate"><span class="pre">case</span></code> statement:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ re2c -S -o example.c example.re
$ sed -i -e <span class="s2">&quot;s/case &#39;7&#39;://&quot;</span> example.c
$ cc -o example example.c
$ ./example
error: lex_line4: at position <span class="m">248</span> <span class="o">(</span>iteration <span class="m">241</span><span class="o">)</span>:
        expected: match length <span class="m">2</span>, rule <span class="m">0</span>
        actual:   match length <span class="m">1</span>, rule <span class="m">254</span>
</pre></div>
</div>
<p>Viola! Now the lexer complains about discrepancy between expected and actual
match results.</p>
<p>One special case of failure detected by skeleton programs is undefined control
flow in the lexer. Use <code class="docutils literal notranslate"><span class="pre">-Wundefined-control-flow</span></code> warning to catch all such
cases in in your code (more details <a class="reference external" href="/manual/manual.html#wundefined-control-flow">here</a>).</p>
</section>
<section id="visualization-and-debug">
<h3>Visualization and debug<a class="headerlink" href="#visualization-and-debug" title="Permalink to this headline">¶</a></h3>
<p>With the <code class="docutils literal notranslate"><span class="pre">-D,</span> <span class="pre">--emit-dot</span></code> option, re2rust does not generate code. Instead,
it dumps the generated DFA in DOT format.
One can convert this dump to an image of the DFA using Graphviz or another library.
Note that this option shows the final DFA after it has gone through a number of
optimizations and transformations. Earlier stages can be dumped with various debug
options, such as <code class="docutils literal notranslate"><span class="pre">--dump-nfa</span></code>, <code class="docutils literal notranslate"><span class="pre">--dump-dfa-raw</span></code> etc. (see the full list of options).</p>
<p>Below is an example of generating a picture of DFA that accepts any UTF-8 code point
(<code class="docutils literal notranslate"><span class="pre">utf8_any.re</span></code>):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/*!re2c</span>
<span class="cm">    *   {}</span>
<span class="cm">    [^] {}</span>
<span class="cm">*/</span><span class="w"></span>
</pre></div>
</div>
<p>Generate and render:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ re2c -D -8 utf8_any.re | dot -Tpng -o utf8_any.png
</pre></div>
</div>
<p>Here is the picture:</p>
<a class="reference internal image-reference" href="../_images/utf8_any.png"><img alt="../_images/utf8_any.png" src="../_images/utf8_any.png" style="width: 90%;" /></a>
</section>
</section>
<section id="more-examples">
<h2>More examples<a class="headerlink" href="#more-examples" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../examples/rust/real_world/example_c.html">C lexer</a></li>
</ul>
</div>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
      Last updated on Feb 16, 2025.
    </div>
  </body>
</html>